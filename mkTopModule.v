//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Wed Jan  3 16:08:43 CET 2018
//
//
// Ports:
// Name                         I/O  size props
// leds                           O    16 reg
// disableSegmentsDisplay         O     7
// disableDotDisplay              O     1 const
// disableDigitDisplay            O     4
// serialOut                      O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// switches_switch_status         I    16 reg
// serialIn_serial_input          I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTopModule(CLK,
		   RST_N,

		   leds,

		   switches_switch_status,

		   disableSegmentsDisplay,

		   disableDotDisplay,

		   disableDigitDisplay,

		   serialOut,

		   serialIn_serial_input);
  input  CLK;
  input  RST_N;

  // value method leds
  output [15 : 0] leds;

  // action method switches
  input  [15 : 0] switches_switch_status;

  // value method disableSegmentsDisplay
  output [6 : 0] disableSegmentsDisplay;

  // value method disableDotDisplay
  output disableDotDisplay;

  // value method disableDigitDisplay
  output [3 : 0] disableDigitDisplay;

  // value method serialOut
  output serialOut;

  // action method serialIn
  input  serialIn_serial_input;

  // signals for module outputs
  reg [6 : 0] disableSegmentsDisplay;
  wire [15 : 0] leds;
  wire [3 : 0] disableDigitDisplay;
  wire disableDotDisplay, serialOut;

  // register buffer
  reg buffer;
  wire buffer$D_IN, buffer$EN;

  // register clockDiv_ctr
  reg [26 : 0] clockDiv_ctr;
  wire [26 : 0] clockDiv_ctr$D_IN;
  wire clockDiv_ctr$EN;

  // register currentDigitIndex
  reg [1 : 0] currentDigitIndex;
  wire [1 : 0] currentDigitIndex$D_IN;
  wire currentDigitIndex$EN;

  // register currentIsSigned
  reg currentIsSigned;
  wire currentIsSigned$D_IN, currentIsSigned$EN;

  // register currentNumberS
  reg [10 : 0] currentNumberS;
  wire [10 : 0] currentNumberS$D_IN;
  wire currentNumberS$EN;

  // register currentNumberU
  reg [3 : 0] currentNumberU;
  wire [3 : 0] currentNumberU$D_IN;
  wire currentNumberU$EN;

  // register displayModule_bcdDecodedInput_0
  reg [3 : 0] displayModule_bcdDecodedInput_0;
  wire [3 : 0] displayModule_bcdDecodedInput_0$D_IN;
  wire displayModule_bcdDecodedInput_0$EN;

  // register displayModule_bcdDecodedInput_1
  reg [3 : 0] displayModule_bcdDecodedInput_1;
  wire [3 : 0] displayModule_bcdDecodedInput_1$D_IN;
  wire displayModule_bcdDecodedInput_1$EN;

  // register displayModule_bcdDecodedInput_2
  reg [3 : 0] displayModule_bcdDecodedInput_2;
  wire [3 : 0] displayModule_bcdDecodedInput_2$D_IN;
  wire displayModule_bcdDecodedInput_2$EN;

  // register displayModule_bcdDecodedInput_3
  reg [3 : 0] displayModule_bcdDecodedInput_3;
  wire [3 : 0] displayModule_bcdDecodedInput_3$D_IN;
  wire displayModule_bcdDecodedInput_3$EN;

  // register displayModule_clockDiv_ctr
  reg [18 : 0] displayModule_clockDiv_ctr;
  wire [18 : 0] displayModule_clockDiv_ctr$D_IN;
  wire displayModule_clockDiv_ctr$EN;

  // register displayModule_currentDigitIndex
  reg [1 : 0] displayModule_currentDigitIndex;
  wire [1 : 0] displayModule_currentDigitIndex$D_IN;
  wire displayModule_currentDigitIndex$EN;

  // register displayModule_doubleDabbleCtr
  reg [3 : 0] displayModule_doubleDabbleCtr;
  wire [3 : 0] displayModule_doubleDabbleCtr$D_IN;
  wire displayModule_doubleDabbleCtr$EN;

  // register displayModule_isNegative
  reg displayModule_isNegative;
  wire displayModule_isNegative$D_IN, displayModule_isNegative$EN;

  // register displayModule_readyToDisplay
  reg displayModule_readyToDisplay;
  wire displayModule_readyToDisplay$D_IN, displayModule_readyToDisplay$EN;

  // register displayModule_toDisplay
  reg [13 : 0] displayModule_toDisplay;
  wire [13 : 0] displayModule_toDisplay$D_IN;
  wire displayModule_toDisplay$EN;

  // register integerParser_buffer
  reg [14 : 0] integerParser_buffer;
  reg [14 : 0] integerParser_buffer$D_IN;
  wire integerParser_buffer$EN;

  // register integerParser_currentBase
  reg [6 : 0] integerParser_currentBase;
  reg [6 : 0] integerParser_currentBase$D_IN;
  wire integerParser_currentBase$EN;

  // register integerParser_currentChar
  reg [8 : 0] integerParser_currentChar;
  wire [8 : 0] integerParser_currentChar$D_IN;
  wire integerParser_currentChar$EN;

  // register integerParser_currentState
  reg [1 : 0] integerParser_currentState;
  reg [1 : 0] integerParser_currentState$D_IN;
  wire integerParser_currentState$EN;

  // register integerParser_isNegative
  reg integerParser_isNegative;
  wire integerParser_isNegative$D_IN, integerParser_isNegative$EN;

  // register integerParser_processedCurrentChar
  reg integerParser_processedCurrentChar;
  reg integerParser_processedCurrentChar$D_IN;
  wire integerParser_processedCurrentChar$EN;

  // register ledStatus
  reg [15 : 0] ledStatus;
  wire [15 : 0] ledStatus$D_IN;
  wire ledStatus$EN;

  // register leftInt
  reg [17 : 0] leftInt;
  wire [17 : 0] leftInt$D_IN;
  wire leftInt$EN;

  // register rightInt
  reg [17 : 0] rightInt;
  wire [17 : 0] rightInt$D_IN;
  wire rightInt$EN;

  // register uartBuf
  reg [7 : 0] uartBuf;
  wire [7 : 0] uartBuf$D_IN;
  wire uartBuf$EN;

  // register uartHandler_clockDiv_ctr
  reg [26 : 0] uartHandler_clockDiv_ctr;
  wire [26 : 0] uartHandler_clockDiv_ctr$D_IN;
  wire uartHandler_clockDiv_ctr$EN;

  // register uartHandler_currentReceivedBit
  reg uartHandler_currentReceivedBit;
  wire uartHandler_currentReceivedBit$D_IN, uartHandler_currentReceivedBit$EN;

  // register uartHandler_currentRecvIndex
  reg [3 : 0] uartHandler_currentRecvIndex;
  wire [3 : 0] uartHandler_currentRecvIndex$D_IN;
  wire uartHandler_currentRecvIndex$EN;

  // register uartHandler_currentSendIndex
  reg [3 : 0] uartHandler_currentSendIndex;
  wire [3 : 0] uartHandler_currentSendIndex$D_IN;
  wire uartHandler_currentSendIndex$EN;

  // register uartHandler_inputFIFO_rCache
  reg [19 : 0] uartHandler_inputFIFO_rCache;
  wire [19 : 0] uartHandler_inputFIFO_rCache$D_IN;
  wire uartHandler_inputFIFO_rCache$EN;

  // register uartHandler_inputFIFO_rRdPtr
  reg [10 : 0] uartHandler_inputFIFO_rRdPtr;
  wire [10 : 0] uartHandler_inputFIFO_rRdPtr$D_IN;
  wire uartHandler_inputFIFO_rRdPtr$EN;

  // register uartHandler_inputFIFO_rWrPtr
  reg [10 : 0] uartHandler_inputFIFO_rWrPtr;
  wire [10 : 0] uartHandler_inputFIFO_rWrPtr$D_IN;
  wire uartHandler_inputFIFO_rWrPtr$EN;

  // register uartHandler_outputFIFO_rCache
  reg [19 : 0] uartHandler_outputFIFO_rCache;
  wire [19 : 0] uartHandler_outputFIFO_rCache$D_IN;
  wire uartHandler_outputFIFO_rCache$EN;

  // register uartHandler_outputFIFO_rRdPtr
  reg [10 : 0] uartHandler_outputFIFO_rRdPtr;
  wire [10 : 0] uartHandler_outputFIFO_rRdPtr$D_IN;
  wire uartHandler_outputFIFO_rRdPtr$EN;

  // register uartHandler_outputFIFO_rWrPtr
  reg [10 : 0] uartHandler_outputFIFO_rWrPtr;
  wire [10 : 0] uartHandler_outputFIFO_rWrPtr$D_IN;
  wire uartHandler_outputFIFO_rWrPtr$EN;

  // register uartHandler_receivedBits
  reg [8 : 0] uartHandler_receivedBits;
  wire [8 : 0] uartHandler_receivedBits$D_IN;
  wire uartHandler_receivedBits$EN;

  // register uartHandler_receivingData
  reg [1 : 0] uartHandler_receivingData;
  reg [1 : 0] uartHandler_receivingData$D_IN;
  wire uartHandler_receivingData$EN;

  // register uartHandler_toSendBits
  reg [11 : 0] uartHandler_toSendBits;
  wire [11 : 0] uartHandler_toSendBits$D_IN;
  wire uartHandler_toSendBits$EN;

  // ports of submodule uartHandler_inputFIFO_memory
  wire [9 : 0] uartHandler_inputFIFO_memory$ADDRA,
	       uartHandler_inputFIFO_memory$ADDRB;
  wire [7 : 0] uartHandler_inputFIFO_memory$DIA,
	       uartHandler_inputFIFO_memory$DIB,
	       uartHandler_inputFIFO_memory$DOB;
  wire uartHandler_inputFIFO_memory$ENA,
       uartHandler_inputFIFO_memory$ENB,
       uartHandler_inputFIFO_memory$WEA,
       uartHandler_inputFIFO_memory$WEB;

  // ports of submodule uartHandler_outputFIFO_memory
  wire [9 : 0] uartHandler_outputFIFO_memory$ADDRA,
	       uartHandler_outputFIFO_memory$ADDRB;
  wire [7 : 0] uartHandler_outputFIFO_memory$DIA,
	       uartHandler_outputFIFO_memory$DIB,
	       uartHandler_outputFIFO_memory$DOB;
  wire uartHandler_outputFIFO_memory$ENA,
       uartHandler_outputFIFO_memory$ENB,
       uartHandler_outputFIFO_memory$WEA,
       uartHandler_outputFIFO_memory$WEB;

  // rule scheduling signals
  wire WILL_FIRE_RL_displayModule_doubleDabble,
       WILL_FIRE_RL_displayModule_iterateDigits,
       WILL_FIRE_RL_feed,
       WILL_FIRE_RL_integerParser_parseBinary,
       WILL_FIRE_RL_integerParser_parseDec,
       WILL_FIRE_RL_integerParser_parseFinish,
       WILL_FIRE_RL_integerParser_parseHex,
       WILL_FIRE_RL_integerParser_parseOctal,
       WILL_FIRE_RL_integerParser_parsePrefix,
       WILL_FIRE_RL_uartHandler_advanceSend,
       WILL_FIRE_RL_uartHandler_enterIntoFIFO,
       WILL_FIRE_RL_uartHandler_prepareForOut,
       WILL_FIRE_RL_uartHandler_startReceiving,
       WILL_FIRE_RL_uartHandler_writeReceivedBit;

  // inputs to muxes for submodule ports
  wire [14 : 0] MUX_integerParser_buffer$write_1__VAL_1,
		MUX_integerParser_buffer$write_1__VAL_2,
		MUX_integerParser_buffer$write_1__VAL_3,
		MUX_integerParser_buffer$write_1__VAL_4;
  wire [13 : 0] MUX_displayModule_toDisplay$write_1__VAL_1,
		MUX_displayModule_toDisplay$write_1__VAL_2;
  wire [11 : 0] MUX_uartHandler_toSendBits$write_1__VAL_2;
  wire [3 : 0] MUX_displayModule_bcdDecodedInput_0$write_1__VAL_1,
	       MUX_displayModule_bcdDecodedInput_0$write_1__VAL_2,
	       MUX_displayModule_bcdDecodedInput_1$write_1__VAL_2,
	       MUX_displayModule_bcdDecodedInput_2$write_1__VAL_2,
	       MUX_displayModule_bcdDecodedInput_3$write_1__VAL_1,
	       MUX_displayModule_bcdDecodedInput_3$write_1__VAL_2,
	       MUX_displayModule_doubleDabbleCtr$write_1__VAL_1,
	       MUX_displayModule_doubleDabbleCtr$write_1__VAL_2,
	       MUX_uartHandler_currentRecvIndex$write_1__VAL_1,
	       MUX_uartHandler_currentSendIndex$write_1__VAL_1;
  wire MUX_displayModule_toDisplay$write_1__SEL_1,
       MUX_integerParser_buffer$write_1__SEL_1,
       MUX_integerParser_buffer$write_1__SEL_2,
       MUX_integerParser_buffer$write_1__SEL_3,
       MUX_integerParser_buffer$write_1__SEL_4,
       MUX_integerParser_currentState$write_1__SEL_1,
       MUX_integerParser_isNegative$write_1__SEL_1,
       MUX_integerParser_processedCurrentChar$write_1__SEL_3,
       MUX_integerParser_processedCurrentChar$write_1__VAL_1,
       MUX_uartHandler_receivingData$write_1__SEL_1,
       MUX_uartHandler_toSendBits$write_1__SEL_1;

  // remaining internal signals
  reg [3 : 0] SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121;
  wire [14 : 0] _0_CONCAT_integerParser_currentChar_84_91_MINUS_48___d192,
		b__h7982,
		integerParser_buffer_BITS_12_TO_0_CONCAT_0_PLU_ETC__q3;
  wire [10 : 0] IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d297,
		uartHandler_toSendBits_BITS_10_TO_0__q1,
		x__h1360,
		x__h1462,
		x__h2322,
		x__h2424;
  wire [8 : 0] x__h3571, y__h3621;
  wire [7 : 0] spliced_bits__h3129,
	       v__h7684,
	       x3__h1277,
	       x3__h2241,
	       x_wget__h1033;
  wire [3 : 0] IF_displayModule_bcdDecodedInput_0_16_ULE_4_39_ETC___d141,
	       IF_displayModule_bcdDecodedInput_1_17_ULE_4_46_ETC___d148,
	       IF_displayModule_bcdDecodedInput_2_18_ULE_4_54_ETC___d156,
	       IF_displayModule_bcdDecodedInput_3_ULE_4_THEN__ETC__q2,
	       x__h9030;
  wire IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298,
       NOT_integerParser_currentChar_84_SLT_48_96___d197;

  // value method leds
  assign leds = { uartBuf, ledStatus[7:0] } ;

  // value method disableSegmentsDisplay
  always@(SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121)
  begin
    case (SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121)
      4'd0: disableSegmentsDisplay = 7'b1000000;
      4'd1: disableSegmentsDisplay = 7'b1111001;
      4'd2: disableSegmentsDisplay = 7'b0100100;
      4'd3: disableSegmentsDisplay = 7'b0110000;
      4'd4: disableSegmentsDisplay = 7'b0011001;
      4'd5: disableSegmentsDisplay = 7'b0010010;
      4'd6: disableSegmentsDisplay = 7'b0000010;
      4'd7: disableSegmentsDisplay = 7'b1111000;
      4'd8: disableSegmentsDisplay = 7'b0;
      4'd9: disableSegmentsDisplay = 7'b0010000;
      4'd10: disableSegmentsDisplay = 7'b0111111;
      default: disableSegmentsDisplay = 7'b1111111;
    endcase
  end

  // value method disableDotDisplay
  assign disableDotDisplay = 1'd1 ;

  // value method disableDigitDisplay
  assign disableDigitDisplay =
	     displayModule_readyToDisplay ? ~x__h9030 : 4'd1 ;

  // value method serialOut
  assign serialOut =
	     !uartHandler_toSendBits[11] ||
	     uartHandler_toSendBits_BITS_10_TO_0__q1[uartHandler_currentSendIndex] ;

  // submodule uartHandler_inputFIFO_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd10),
	  .DATA_WIDTH(32'd8),
	  .MEMSIZE(11'd1024)) uartHandler_inputFIFO_memory(.CLKA(CLK),
							   .CLKB(CLK),
							   .ADDRA(uartHandler_inputFIFO_memory$ADDRA),
							   .ADDRB(uartHandler_inputFIFO_memory$ADDRB),
							   .DIA(uartHandler_inputFIFO_memory$DIA),
							   .DIB(uartHandler_inputFIFO_memory$DIB),
							   .WEA(uartHandler_inputFIFO_memory$WEA),
							   .WEB(uartHandler_inputFIFO_memory$WEB),
							   .ENA(uartHandler_inputFIFO_memory$ENA),
							   .ENB(uartHandler_inputFIFO_memory$ENB),
							   .DOA(),
							   .DOB(uartHandler_inputFIFO_memory$DOB));

  // submodule uartHandler_outputFIFO_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd10),
	  .DATA_WIDTH(32'd8),
	  .MEMSIZE(11'd1024)) uartHandler_outputFIFO_memory(.CLKA(CLK),
							    .CLKB(CLK),
							    .ADDRA(uartHandler_outputFIFO_memory$ADDRA),
							    .ADDRB(uartHandler_outputFIFO_memory$ADDRB),
							    .DIA(uartHandler_outputFIFO_memory$DIA),
							    .DIB(uartHandler_outputFIFO_memory$DIB),
							    .WEA(uartHandler_outputFIFO_memory$WEA),
							    .WEB(uartHandler_outputFIFO_memory$WEB),
							    .ENA(uartHandler_outputFIFO_memory$ENA),
							    .ENB(uartHandler_outputFIFO_memory$ENB),
							    .DOA(),
							    .DOB(uartHandler_outputFIFO_memory$DOB));

  // rule RL_uartHandler_advanceSend
  assign WILL_FIRE_RL_uartHandler_advanceSend =
	     uartHandler_toSendBits[11] && uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_uartHandler_startReceiving
  assign WILL_FIRE_RL_uartHandler_startReceiving =
	     !uartHandler_currentReceivedBit &&
	     uartHandler_receivingData == 2'd0 &&
	     uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_uartHandler_writeReceivedBit
  assign WILL_FIRE_RL_uartHandler_writeReceivedBit =
	     uartHandler_receivingData == 2'd1 &&
	     uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_uartHandler_enterIntoFIFO
  assign WILL_FIRE_RL_uartHandler_enterIntoFIFO =
	     uartHandler_outputFIFO_rRdPtr + 11'd512 !=
	     uartHandler_outputFIFO_rWrPtr &&
	     uartHandler_receivingData == 2'd2 &&
	     uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_uartHandler_prepareForOut
  assign WILL_FIRE_RL_uartHandler_prepareForOut =
	     uartHandler_inputFIFO_rRdPtr != uartHandler_inputFIFO_rWrPtr &&
	     !uartHandler_toSendBits[11] &&
	     uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_feed
  assign WILL_FIRE_RL_feed =
	     uartHandler_outputFIFO_rRdPtr != uartHandler_outputFIFO_rWrPtr &&
	     uartHandler_inputFIFO_rRdPtr + 11'd512 !=
	     uartHandler_inputFIFO_rWrPtr &&
	     integerParser_processedCurrentChar ;

  // rule RL_displayModule_iterateDigits
  assign WILL_FIRE_RL_displayModule_iterateDigits =
	     displayModule_readyToDisplay &&
	     displayModule_clockDiv_ctr == 19'd0 ;

  // rule RL_displayModule_doubleDabble
  assign WILL_FIRE_RL_displayModule_doubleDabble =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // rule RL_integerParser_parseBinary
  assign WILL_FIRE_RL_integerParser_parseBinary =
	     integerParser_currentState == 2'd1 &&
	     !integerParser_processedCurrentChar &&
	     integerParser_currentBase == 7'd2 &&
	     !WILL_FIRE_RL_integerParser_parseFinish ;

  // rule RL_integerParser_parseOctal
  assign WILL_FIRE_RL_integerParser_parseOctal =
	     integerParser_currentState == 2'd1 &&
	     !integerParser_processedCurrentChar &&
	     integerParser_currentBase == 7'd8 &&
	     !WILL_FIRE_RL_integerParser_parseFinish ;

  // rule RL_integerParser_parseHex
  assign WILL_FIRE_RL_integerParser_parseHex =
	     integerParser_currentState == 2'd1 &&
	     !integerParser_processedCurrentChar &&
	     integerParser_currentBase == 7'd16 &&
	     !WILL_FIRE_RL_integerParser_parseFinish ;

  // rule RL_integerParser_parseDec
  assign WILL_FIRE_RL_integerParser_parseDec =
	     integerParser_currentState == 2'd1 &&
	     !integerParser_processedCurrentChar &&
	     integerParser_currentBase == 7'd10 &&
	     !WILL_FIRE_RL_integerParser_parseFinish ;

  // rule RL_integerParser_parseFinish
  assign WILL_FIRE_RL_integerParser_parseFinish =
	     integerParser_currentState == 2'd1 &&
	     !integerParser_processedCurrentChar &&
	     (integerParser_currentChar == 9'd13 ||
	      integerParser_currentChar == 9'd10) ;

  // rule RL_integerParser_parsePrefix
  assign WILL_FIRE_RL_integerParser_parsePrefix =
	     integerParser_currentState == 2'd0 &&
	     !integerParser_processedCurrentChar ;

  // inputs to muxes for submodule ports
  assign MUX_displayModule_toDisplay$write_1__SEL_1 =
	     integerParser_currentState == 2'd2 &&
	     IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 ;
  assign MUX_integerParser_buffer$write_1__SEL_1 =
	     WILL_FIRE_RL_integerParser_parseDec &&
	     NOT_integerParser_currentChar_84_SLT_48_96___d197 &&
	     (integerParser_currentChar ^ 9'h100) <= 9'd313 ;
  assign MUX_integerParser_buffer$write_1__SEL_2 =
	     WILL_FIRE_RL_integerParser_parseBinary &&
	     (integerParser_currentChar == 9'd48 ||
	      integerParser_currentChar == 9'd49) ;
  assign MUX_integerParser_buffer$write_1__SEL_3 =
	     WILL_FIRE_RL_integerParser_parseOctal &&
	     NOT_integerParser_currentChar_84_SLT_48_96___d197 &&
	     (integerParser_currentChar ^ 9'h100) <= 9'd311 ;
  assign MUX_integerParser_buffer$write_1__SEL_4 =
	     WILL_FIRE_RL_integerParser_parseHex &&
	     (NOT_integerParser_currentChar_84_SLT_48_96___d197 &&
	      (integerParser_currentChar ^ 9'h100) <= 9'd313 ||
	      (integerParser_currentChar ^ 9'h100) >= 9'd321 &&
	      (integerParser_currentChar ^ 9'h100) <= 9'd326 ||
	      (integerParser_currentChar ^ 9'h100) >= 9'd353 &&
	      (integerParser_currentChar ^ 9'h100) <= 9'd358) ;
  assign MUX_integerParser_currentState$write_1__SEL_1 =
	     WILL_FIRE_RL_integerParser_parsePrefix &&
	     integerParser_currentChar != 9'd48 &&
	     integerParser_currentChar != 9'd45 ;
  assign MUX_integerParser_isNegative$write_1__SEL_1 =
	     WILL_FIRE_RL_integerParser_parsePrefix &&
	     integerParser_currentChar == 9'd45 ;
  assign MUX_integerParser_processedCurrentChar$write_1__SEL_3 =
	     WILL_FIRE_RL_integerParser_parseBinary ||
	     WILL_FIRE_RL_integerParser_parseDec ||
	     WILL_FIRE_RL_integerParser_parseOctal ||
	     WILL_FIRE_RL_integerParser_parseHex ||
	     WILL_FIRE_RL_integerParser_parseFinish ;
  assign MUX_uartHandler_receivingData$write_1__SEL_1 =
	     WILL_FIRE_RL_uartHandler_writeReceivedBit &&
	     uartHandler_currentRecvIndex == 4'd7 ;
  assign MUX_uartHandler_toSendBits$write_1__SEL_1 =
	     WILL_FIRE_RL_uartHandler_advanceSend &&
	     uartHandler_currentSendIndex == 4'd10 ;
  assign MUX_displayModule_bcdDecodedInput_0$write_1__VAL_1 =
	     IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 ?
	       4'd0 :
	       4'd10 ;
  assign MUX_displayModule_bcdDecodedInput_0$write_1__VAL_2 =
	     { IF_displayModule_bcdDecodedInput_0_16_ULE_4_39_ETC___d141[2:0],
	       1'd0 } +
	     { 3'd0, displayModule_toDisplay[13] } ;
  assign MUX_displayModule_bcdDecodedInput_1$write_1__VAL_2 =
	     { IF_displayModule_bcdDecodedInput_1_17_ULE_4_46_ETC___d148[2:0],
	       1'd0 } +
	     { 3'd0,
	       IF_displayModule_bcdDecodedInput_0_16_ULE_4_39_ETC___d141[3] } ;
  assign MUX_displayModule_bcdDecodedInput_2$write_1__VAL_2 =
	     { IF_displayModule_bcdDecodedInput_2_18_ULE_4_54_ETC___d156[2:0],
	       1'd0 } +
	     { 3'd0,
	       IF_displayModule_bcdDecodedInput_1_17_ULE_4_46_ETC___d148[3] } ;
  assign MUX_displayModule_bcdDecodedInput_3$write_1__VAL_1 =
	     IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 ?
	       (b__h7982[10] ? 4'd10 : 4'd0) :
	       4'd10 ;
  assign MUX_displayModule_bcdDecodedInput_3$write_1__VAL_2 =
	     displayModule_isNegative ?
	       displayModule_bcdDecodedInput_3 :
	       { IF_displayModule_bcdDecodedInput_3_ULE_4_THEN__ETC__q2[2:0],
		 1'd0 } +
	       { 3'd0,
		 IF_displayModule_bcdDecodedInput_2_18_ULE_4_54_ETC___d156[3] } ;
  assign MUX_displayModule_doubleDabbleCtr$write_1__VAL_1 =
	     IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 ?
	       4'd0 :
	       4'd14 ;
  assign MUX_displayModule_doubleDabbleCtr$write_1__VAL_2 =
	     displayModule_doubleDabbleCtr + 4'd1 ;
  assign MUX_displayModule_toDisplay$write_1__VAL_1 =
	     { 3'd0,
	       IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d297 } ;
  assign MUX_displayModule_toDisplay$write_1__VAL_2 =
	     { displayModule_toDisplay[12:0], 1'd0 } ;
  assign MUX_integerParser_buffer$write_1__VAL_1 =
	     { integerParser_buffer_BITS_12_TO_0_CONCAT_0_PLU_ETC__q3[13:0],
	       1'd0 } +
	     _0_CONCAT_integerParser_currentChar_84_91_MINUS_48___d192 ;
  assign MUX_integerParser_buffer$write_1__VAL_2 =
	     { integerParser_buffer[13:0], 1'd0 } +
	     _0_CONCAT_integerParser_currentChar_84_91_MINUS_48___d192 ;
  assign MUX_integerParser_buffer$write_1__VAL_3 =
	     { integerParser_buffer[11:0], 3'd0 } +
	     _0_CONCAT_integerParser_currentChar_84_91_MINUS_48___d192 ;
  assign MUX_integerParser_buffer$write_1__VAL_4 =
	     (NOT_integerParser_currentChar_84_SLT_48_96___d197 &&
	      (integerParser_currentChar ^ 9'h100) <= 9'd313) ?
	       { integerParser_buffer[10:0], 4'd0 } +
	       _0_CONCAT_integerParser_currentChar_84_91_MINUS_48___d192 :
	       (((integerParser_currentChar ^ 9'h100) >= 9'd321 &&
		 (integerParser_currentChar ^ 9'h100) <= 9'd326) ?
		  { integerParser_buffer[10:0], 4'd0 } +
		  ({ 6'd0, integerParser_currentChar } - 15'd55) :
		  { integerParser_buffer[10:0], 4'd0 } +
		  ({ 6'd0, integerParser_currentChar } - 15'd87)) ;
  assign MUX_integerParser_processedCurrentChar$write_1__VAL_1 =
	     integerParser_currentChar == 9'd120 ||
	     integerParser_currentChar == 9'd88 ||
	     integerParser_currentChar == 9'd104 ||
	     integerParser_currentChar == 9'd72 ||
	     integerParser_currentChar == 9'd111 ||
	     integerParser_currentChar == 9'd79 ||
	     integerParser_currentChar == 9'd98 ||
	     integerParser_currentChar == 9'd66 ||
	     integerParser_currentChar == 9'd100 ||
	     integerParser_currentChar == 9'd68 ||
	     integerParser_currentChar == 9'd48 ||
	     integerParser_currentChar == 9'd45 ;
  assign MUX_uartHandler_currentRecvIndex$write_1__VAL_1 =
	     uartHandler_currentRecvIndex + 4'd1 ;
  assign MUX_uartHandler_currentSendIndex$write_1__VAL_1 =
	     uartHandler_currentSendIndex + 4'd1 ;
  assign MUX_uartHandler_toSendBits$write_1__VAL_2 =
	     { 3'd7, spliced_bits__h3129, 1'd0 } ;

  // register buffer
  assign buffer$D_IN = 1'b0 ;
  assign buffer$EN = 1'b0 ;

  // register clockDiv_ctr
  assign clockDiv_ctr$D_IN = clockDiv_ctr + 27'd1 ;
  assign clockDiv_ctr$EN = 1'd1 ;

  // register currentDigitIndex
  assign currentDigitIndex$D_IN = 2'h0 ;
  assign currentDigitIndex$EN = 1'b0 ;

  // register currentIsSigned
  assign currentIsSigned$D_IN = 1'b0 ;
  assign currentIsSigned$EN = 1'b0 ;

  // register currentNumberS
  assign currentNumberS$D_IN = 11'h0 ;
  assign currentNumberS$EN = 1'b0 ;

  // register currentNumberU
  assign currentNumberU$D_IN = 4'h0 ;
  assign currentNumberU$EN = 1'b0 ;

  // register displayModule_bcdDecodedInput_0
  assign displayModule_bcdDecodedInput_0$D_IN =
	     (integerParser_currentState == 2'd2) ?
	       MUX_displayModule_bcdDecodedInput_0$write_1__VAL_1 :
	       MUX_displayModule_bcdDecodedInput_0$write_1__VAL_2 ;
  assign displayModule_bcdDecodedInput_0$EN =
	     integerParser_currentState == 2'd2 ||
	     WILL_FIRE_RL_displayModule_doubleDabble ;

  // register displayModule_bcdDecodedInput_1
  assign displayModule_bcdDecodedInput_1$D_IN =
	     (integerParser_currentState == 2'd2) ?
	       MUX_displayModule_bcdDecodedInput_0$write_1__VAL_1 :
	       MUX_displayModule_bcdDecodedInput_1$write_1__VAL_2 ;
  assign displayModule_bcdDecodedInput_1$EN =
	     integerParser_currentState == 2'd2 ||
	     WILL_FIRE_RL_displayModule_doubleDabble ;

  // register displayModule_bcdDecodedInput_2
  assign displayModule_bcdDecodedInput_2$D_IN =
	     (integerParser_currentState == 2'd2) ?
	       MUX_displayModule_bcdDecodedInput_0$write_1__VAL_1 :
	       MUX_displayModule_bcdDecodedInput_2$write_1__VAL_2 ;
  assign displayModule_bcdDecodedInput_2$EN =
	     integerParser_currentState == 2'd2 ||
	     WILL_FIRE_RL_displayModule_doubleDabble ;

  // register displayModule_bcdDecodedInput_3
  assign displayModule_bcdDecodedInput_3$D_IN =
	     (integerParser_currentState == 2'd2) ?
	       MUX_displayModule_bcdDecodedInput_3$write_1__VAL_1 :
	       MUX_displayModule_bcdDecodedInput_3$write_1__VAL_2 ;
  assign displayModule_bcdDecodedInput_3$EN =
	     integerParser_currentState == 2'd2 ||
	     WILL_FIRE_RL_displayModule_doubleDabble ;

  // register displayModule_clockDiv_ctr
  assign displayModule_clockDiv_ctr$D_IN =
	     displayModule_clockDiv_ctr + 19'd1 ;
  assign displayModule_clockDiv_ctr$EN = 1'd1 ;

  // register displayModule_currentDigitIndex
  assign displayModule_currentDigitIndex$D_IN =
	     displayModule_currentDigitIndex + 2'd1 ;
  assign displayModule_currentDigitIndex$EN =
	     WILL_FIRE_RL_displayModule_iterateDigits ;

  // register displayModule_doubleDabbleCtr
  assign displayModule_doubleDabbleCtr$D_IN =
	     (integerParser_currentState == 2'd2) ?
	       MUX_displayModule_doubleDabbleCtr$write_1__VAL_1 :
	       MUX_displayModule_doubleDabbleCtr$write_1__VAL_2 ;
  assign displayModule_doubleDabbleCtr$EN =
	     WILL_FIRE_RL_displayModule_doubleDabble ||
	     integerParser_currentState == 2'd2 ;

  // register displayModule_isNegative
  assign displayModule_isNegative$D_IN = b__h7982[10] ;
  assign displayModule_isNegative$EN =
	     MUX_displayModule_toDisplay$write_1__SEL_1 ;

  // register displayModule_readyToDisplay
  assign displayModule_readyToDisplay$D_IN =
	     (integerParser_currentState == 2'd2) ?
	       !IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 :
	       displayModule_doubleDabbleCtr == 4'd13 ;
  assign displayModule_readyToDisplay$EN =
	     WILL_FIRE_RL_displayModule_doubleDabble ||
	     integerParser_currentState == 2'd2 ;

  // register displayModule_toDisplay
  assign displayModule_toDisplay$D_IN =
	     MUX_displayModule_toDisplay$write_1__SEL_1 ?
	       MUX_displayModule_toDisplay$write_1__VAL_1 :
	       MUX_displayModule_toDisplay$write_1__VAL_2 ;
  assign displayModule_toDisplay$EN =
	     integerParser_currentState == 2'd2 &&
	     IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 ||
	     WILL_FIRE_RL_displayModule_doubleDabble ;

  // register integerParser_buffer
  always@(MUX_integerParser_buffer$write_1__SEL_1 or
	  MUX_integerParser_buffer$write_1__VAL_1 or
	  MUX_integerParser_buffer$write_1__SEL_2 or
	  MUX_integerParser_buffer$write_1__VAL_2 or
	  MUX_integerParser_buffer$write_1__SEL_3 or
	  MUX_integerParser_buffer$write_1__VAL_3 or
	  MUX_integerParser_buffer$write_1__SEL_4 or
	  MUX_integerParser_buffer$write_1__VAL_4 or
	  integerParser_currentState)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_integerParser_buffer$write_1__SEL_1:
	  integerParser_buffer$D_IN = MUX_integerParser_buffer$write_1__VAL_1;
      MUX_integerParser_buffer$write_1__SEL_2:
	  integerParser_buffer$D_IN = MUX_integerParser_buffer$write_1__VAL_2;
      MUX_integerParser_buffer$write_1__SEL_3:
	  integerParser_buffer$D_IN = MUX_integerParser_buffer$write_1__VAL_3;
      MUX_integerParser_buffer$write_1__SEL_4:
	  integerParser_buffer$D_IN = MUX_integerParser_buffer$write_1__VAL_4;
      integerParser_currentState == 2'd2: integerParser_buffer$D_IN = 15'd0;
      default: integerParser_buffer$D_IN =
		   15'b010101010101010 /* unspecified value */ ;
    endcase
  end
  assign integerParser_buffer$EN =
	     WILL_FIRE_RL_integerParser_parseDec &&
	     NOT_integerParser_currentChar_84_SLT_48_96___d197 &&
	     (integerParser_currentChar ^ 9'h100) <= 9'd313 ||
	     WILL_FIRE_RL_integerParser_parseBinary &&
	     (integerParser_currentChar == 9'd48 ||
	      integerParser_currentChar == 9'd49) ||
	     WILL_FIRE_RL_integerParser_parseOctal &&
	     NOT_integerParser_currentChar_84_SLT_48_96___d197 &&
	     (integerParser_currentChar ^ 9'h100) <= 9'd311 ||
	     MUX_integerParser_buffer$write_1__SEL_4 ||
	     integerParser_currentState == 2'd2 ;

  // register integerParser_currentBase
  always@(integerParser_currentChar)
  begin
    case (integerParser_currentChar)
      9'd66, 9'd98: integerParser_currentBase$D_IN = 7'd2;
      9'd72, 9'd88, 9'd104, 9'd120: integerParser_currentBase$D_IN = 7'd16;
      9'd79, 9'd111: integerParser_currentBase$D_IN = 7'd8;
      default: integerParser_currentBase$D_IN = 7'd10;
    endcase
  end
  assign integerParser_currentBase$EN =
	     MUX_integerParser_currentState$write_1__SEL_1 ;

  // register integerParser_currentChar
  assign integerParser_currentChar$D_IN = { 1'd0, v__h7684 } ;
  assign integerParser_currentChar$EN = WILL_FIRE_RL_feed ;

  // register integerParser_currentState
  always@(MUX_integerParser_currentState$write_1__SEL_1 or
	  integerParser_currentState or
	  WILL_FIRE_RL_integerParser_parseFinish)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_integerParser_currentState$write_1__SEL_1:
	  integerParser_currentState$D_IN = 2'd1;
      integerParser_currentState == 2'd2:
	  integerParser_currentState$D_IN = 2'd0;
      WILL_FIRE_RL_integerParser_parseFinish:
	  integerParser_currentState$D_IN = 2'd2;
      default: integerParser_currentState$D_IN =
		   2'b10 /* unspecified value */ ;
    endcase
  end
  assign integerParser_currentState$EN =
	     WILL_FIRE_RL_integerParser_parsePrefix &&
	     integerParser_currentChar != 9'd48 &&
	     integerParser_currentChar != 9'd45 ||
	     integerParser_currentState == 2'd2 ||
	     WILL_FIRE_RL_integerParser_parseFinish ;

  // register integerParser_isNegative
  assign integerParser_isNegative$D_IN =
	     MUX_integerParser_isNegative$write_1__SEL_1 &&
	     !integerParser_isNegative ;
  assign integerParser_isNegative$EN =
	     WILL_FIRE_RL_integerParser_parsePrefix &&
	     integerParser_currentChar == 9'd45 ||
	     integerParser_currentState == 2'd2 ;

  // register integerParser_processedCurrentChar
  always@(WILL_FIRE_RL_integerParser_parsePrefix or
	  MUX_integerParser_processedCurrentChar$write_1__VAL_1 or
	  WILL_FIRE_RL_feed or
	  MUX_integerParser_processedCurrentChar$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_integerParser_parsePrefix:
	  integerParser_processedCurrentChar$D_IN =
	      MUX_integerParser_processedCurrentChar$write_1__VAL_1;
      WILL_FIRE_RL_feed: integerParser_processedCurrentChar$D_IN = 1'd0;
      MUX_integerParser_processedCurrentChar$write_1__SEL_3:
	  integerParser_processedCurrentChar$D_IN = 1'd1;
      default: integerParser_processedCurrentChar$D_IN =
		   1'b0 /* unspecified value */ ;
    endcase
  end
  assign integerParser_processedCurrentChar$EN =
	     WILL_FIRE_RL_integerParser_parsePrefix || WILL_FIRE_RL_feed ||
	     WILL_FIRE_RL_integerParser_parseBinary ||
	     WILL_FIRE_RL_integerParser_parseDec ||
	     WILL_FIRE_RL_integerParser_parseOctal ||
	     WILL_FIRE_RL_integerParser_parseHex ||
	     WILL_FIRE_RL_integerParser_parseFinish ;

  // register ledStatus
  assign ledStatus$D_IN = switches_switch_status ;
  assign ledStatus$EN = 1'd1 ;

  // register leftInt
  assign leftInt$D_IN = { 10'd0, switches_switch_status[15:8] } ;
  assign leftInt$EN = 1'd1 ;

  // register rightInt
  assign rightInt$D_IN = { 10'd0, switches_switch_status[7:0] } ;
  assign rightInt$EN = 1'd1 ;

  // register uartBuf
  assign uartBuf$D_IN = v__h7684 ;
  assign uartBuf$EN = WILL_FIRE_RL_feed ;

  // register uartHandler_clockDiv_ctr
  assign uartHandler_clockDiv_ctr$D_IN =
	     (uartHandler_clockDiv_ctr < 27'd10415) ?
	       uartHandler_clockDiv_ctr + 27'd1 :
	       27'd0 ;
  assign uartHandler_clockDiv_ctr$EN = 1'd1 ;

  // register uartHandler_currentReceivedBit
  assign uartHandler_currentReceivedBit$D_IN = serialIn_serial_input ;
  assign uartHandler_currentReceivedBit$EN = 1'd1 ;

  // register uartHandler_currentRecvIndex
  assign uartHandler_currentRecvIndex$D_IN =
	     WILL_FIRE_RL_uartHandler_writeReceivedBit ?
	       MUX_uartHandler_currentRecvIndex$write_1__VAL_1 :
	       4'd0 ;
  assign uartHandler_currentRecvIndex$EN =
	     WILL_FIRE_RL_uartHandler_writeReceivedBit ||
	     WILL_FIRE_RL_uartHandler_startReceiving ;

  // register uartHandler_currentSendIndex
  assign uartHandler_currentSendIndex$D_IN =
	     WILL_FIRE_RL_uartHandler_advanceSend ?
	       MUX_uartHandler_currentSendIndex$write_1__VAL_1 :
	       4'd0 ;
  assign uartHandler_currentSendIndex$EN =
	     WILL_FIRE_RL_uartHandler_advanceSend ||
	     WILL_FIRE_RL_uartHandler_prepareForOut ;

  // register uartHandler_inputFIFO_rCache
  assign uartHandler_inputFIFO_rCache$D_IN =
	     { 1'd1, uartHandler_inputFIFO_rWrPtr, x3__h1277 } ;
  assign uartHandler_inputFIFO_rCache$EN = WILL_FIRE_RL_feed ;

  // register uartHandler_inputFIFO_rRdPtr
  assign uartHandler_inputFIFO_rRdPtr$D_IN = x__h1462 ;
  assign uartHandler_inputFIFO_rRdPtr$EN =
	     WILL_FIRE_RL_uartHandler_prepareForOut ;

  // register uartHandler_inputFIFO_rWrPtr
  assign uartHandler_inputFIFO_rWrPtr$D_IN = x__h1360 ;
  assign uartHandler_inputFIFO_rWrPtr$EN = WILL_FIRE_RL_feed ;

  // register uartHandler_outputFIFO_rCache
  assign uartHandler_outputFIFO_rCache$D_IN =
	     { 1'd1, uartHandler_outputFIFO_rWrPtr, x3__h2241 } ;
  assign uartHandler_outputFIFO_rCache$EN =
	     WILL_FIRE_RL_uartHandler_enterIntoFIFO ;

  // register uartHandler_outputFIFO_rRdPtr
  assign uartHandler_outputFIFO_rRdPtr$D_IN = x__h2424 ;
  assign uartHandler_outputFIFO_rRdPtr$EN = WILL_FIRE_RL_feed ;

  // register uartHandler_outputFIFO_rWrPtr
  assign uartHandler_outputFIFO_rWrPtr$D_IN = x__h2322 ;
  assign uartHandler_outputFIFO_rWrPtr$EN =
	     WILL_FIRE_RL_uartHandler_enterIntoFIFO ;

  // register uartHandler_receivedBits
  assign uartHandler_receivedBits$D_IN =
	     uartHandler_currentReceivedBit ?
	       uartHandler_receivedBits | x__h3571 :
	       uartHandler_receivedBits & y__h3621 ;
  assign uartHandler_receivedBits$EN =
	     WILL_FIRE_RL_uartHandler_writeReceivedBit ;

  // register uartHandler_receivingData
  always@(MUX_uartHandler_receivingData$write_1__SEL_1 or
	  WILL_FIRE_RL_uartHandler_enterIntoFIFO or
	  WILL_FIRE_RL_uartHandler_startReceiving)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_uartHandler_receivingData$write_1__SEL_1:
	  uartHandler_receivingData$D_IN = 2'd2;
      WILL_FIRE_RL_uartHandler_enterIntoFIFO:
	  uartHandler_receivingData$D_IN = 2'd0;
      WILL_FIRE_RL_uartHandler_startReceiving:
	  uartHandler_receivingData$D_IN = 2'd1;
      default: uartHandler_receivingData$D_IN =
		   2'b10 /* unspecified value */ ;
    endcase
  end
  assign uartHandler_receivingData$EN =
	     WILL_FIRE_RL_uartHandler_writeReceivedBit &&
	     uartHandler_currentRecvIndex == 4'd7 ||
	     WILL_FIRE_RL_uartHandler_enterIntoFIFO ||
	     WILL_FIRE_RL_uartHandler_startReceiving ;

  // register uartHandler_toSendBits
  assign uartHandler_toSendBits$D_IN =
	     MUX_uartHandler_toSendBits$write_1__SEL_1 ?
	       12'd682 :
	       MUX_uartHandler_toSendBits$write_1__VAL_2 ;
  assign uartHandler_toSendBits$EN =
	     WILL_FIRE_RL_uartHandler_advanceSend &&
	     uartHandler_currentSendIndex == 4'd10 ||
	     WILL_FIRE_RL_uartHandler_prepareForOut ;

  // submodule uartHandler_inputFIFO_memory
  assign uartHandler_inputFIFO_memory$ADDRA =
	     uartHandler_inputFIFO_rWrPtr[9:0] ;
  assign uartHandler_inputFIFO_memory$ADDRB =
	     WILL_FIRE_RL_uartHandler_prepareForOut ?
	       x__h1462[9:0] :
	       uartHandler_inputFIFO_rRdPtr[9:0] ;
  assign uartHandler_inputFIFO_memory$DIA = x3__h1277 ;
  assign uartHandler_inputFIFO_memory$DIB =
	     8'b10101010 /* unspecified value */  ;
  assign uartHandler_inputFIFO_memory$WEA = WILL_FIRE_RL_feed ;
  assign uartHandler_inputFIFO_memory$WEB = 1'd0 ;
  assign uartHandler_inputFIFO_memory$ENA = 1'b1 ;
  assign uartHandler_inputFIFO_memory$ENB = 1'b1 ;

  // submodule uartHandler_outputFIFO_memory
  assign uartHandler_outputFIFO_memory$ADDRA =
	     uartHandler_outputFIFO_rWrPtr[9:0] ;
  assign uartHandler_outputFIFO_memory$ADDRB =
	     WILL_FIRE_RL_feed ?
	       x__h2424[9:0] :
	       uartHandler_outputFIFO_rRdPtr[9:0] ;
  assign uartHandler_outputFIFO_memory$DIA = x3__h2241 ;
  assign uartHandler_outputFIFO_memory$DIB =
	     8'b10101010 /* unspecified value */  ;
  assign uartHandler_outputFIFO_memory$WEA =
	     WILL_FIRE_RL_uartHandler_enterIntoFIFO ;
  assign uartHandler_outputFIFO_memory$WEB = 1'd0 ;
  assign uartHandler_outputFIFO_memory$ENA = 1'b1 ;
  assign uartHandler_outputFIFO_memory$ENB = 1'b1 ;

  // remaining internal signals
  assign IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d297 =
	     b__h7982[10] ? -b__h7982[10:0] : b__h7982[10:0] ;
  assign IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d298 =
	     (IF_IF_integerParser_isNegative_67_THEN_NEG_int_ETC___d297 ^
	      11'h400) <=
	     11'd2023 ;
  assign IF_displayModule_bcdDecodedInput_0_16_ULE_4_39_ETC___d141 =
	     (displayModule_bcdDecodedInput_0 <= 4'd4) ?
	       displayModule_bcdDecodedInput_0 :
	       displayModule_bcdDecodedInput_0 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_1_17_ULE_4_46_ETC___d148 =
	     (displayModule_bcdDecodedInput_1 <= 4'd4) ?
	       displayModule_bcdDecodedInput_1 :
	       displayModule_bcdDecodedInput_1 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_2_18_ULE_4_54_ETC___d156 =
	     (displayModule_bcdDecodedInput_2 <= 4'd4) ?
	       displayModule_bcdDecodedInput_2 :
	       displayModule_bcdDecodedInput_2 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_3_ULE_4_THEN__ETC__q2 =
	     (displayModule_bcdDecodedInput_3 <= 4'd4) ?
	       displayModule_bcdDecodedInput_3 :
	       displayModule_bcdDecodedInput_3 + 4'd3 ;
  assign NOT_integerParser_currentChar_84_SLT_48_96___d197 =
	     (integerParser_currentChar ^ 9'h100) >= 9'd304 ;
  assign _0_CONCAT_integerParser_currentChar_84_91_MINUS_48___d192 =
	     { 6'd0, integerParser_currentChar } - 15'd48 ;
  assign b__h7982 =
	     integerParser_isNegative ?
	       -integerParser_buffer :
	       integerParser_buffer ;
  assign integerParser_buffer_BITS_12_TO_0_CONCAT_0_PLU_ETC__q3 =
	     { integerParser_buffer[12:0], 2'd0 } + integerParser_buffer ;
  assign spliced_bits__h3129 =
	     (uartHandler_inputFIFO_rCache[19] &&
	      uartHandler_inputFIFO_rCache[18:8] ==
	      uartHandler_inputFIFO_rRdPtr) ?
	       uartHandler_inputFIFO_rCache[7:0] :
	       uartHandler_inputFIFO_memory$DOB ;
  assign uartHandler_toSendBits_BITS_10_TO_0__q1 =
	     uartHandler_toSendBits[10:0] ;
  assign v__h7684 =
	     (uartHandler_outputFIFO_rCache[19] &&
	      uartHandler_outputFIFO_rCache[18:8] ==
	      uartHandler_outputFIFO_rRdPtr) ?
	       uartHandler_outputFIFO_rCache[7:0] :
	       uartHandler_outputFIFO_memory$DOB ;
  assign x3__h1277 = WILL_FIRE_RL_feed ? x_wget__h1033 : 8'd0 ;
  assign x3__h2241 =
	     WILL_FIRE_RL_uartHandler_enterIntoFIFO ?
	       uartHandler_receivedBits[7:0] :
	       8'd0 ;
  assign x__h1360 = uartHandler_inputFIFO_rWrPtr + 11'd1 ;
  assign x__h1462 = uartHandler_inputFIFO_rRdPtr + 11'd1 ;
  assign x__h2322 = uartHandler_outputFIFO_rWrPtr + 11'd1 ;
  assign x__h2424 = uartHandler_outputFIFO_rRdPtr + 11'd1 ;
  assign x__h3571 = 9'd1 << uartHandler_currentRecvIndex ;
  assign x__h9030 = 4'd1 << displayModule_currentDigitIndex ;
  assign x_wget__h1033 = v__h7684 ;
  assign y__h3621 = ~x__h3571 ;
  always@(displayModule_currentDigitIndex or
	  displayModule_bcdDecodedInput_0 or
	  displayModule_bcdDecodedInput_1 or
	  displayModule_bcdDecodedInput_2 or displayModule_bcdDecodedInput_3)
  begin
    case (displayModule_currentDigitIndex)
      2'd0:
	  SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121 =
	      displayModule_bcdDecodedInput_0;
      2'd1:
	  SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121 =
	      displayModule_bcdDecodedInput_1;
      2'd2:
	  SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121 =
	      displayModule_bcdDecodedInput_2;
      2'd3:
	  SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121 =
	      displayModule_bcdDecodedInput_3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 27'd0;
	currentDigitIndex <= `BSV_ASSIGNMENT_DELAY 2'd0;
	currentIsSigned <= `BSV_ASSIGNMENT_DELAY 1'd0;
	currentNumberS <= `BSV_ASSIGNMENT_DELAY 11'd0;
	currentNumberU <= `BSV_ASSIGNMENT_DELAY 4'd0;
	displayModule_bcdDecodedInput_0 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_bcdDecodedInput_1 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_bcdDecodedInput_2 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_bcdDecodedInput_3 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 19'd0;
	displayModule_currentDigitIndex <= `BSV_ASSIGNMENT_DELAY 2'd0;
	displayModule_isNegative <= `BSV_ASSIGNMENT_DELAY 1'd0;
	displayModule_readyToDisplay <= `BSV_ASSIGNMENT_DELAY 1'd0;
	integerParser_buffer <= `BSV_ASSIGNMENT_DELAY 15'd0;
	integerParser_currentState <= `BSV_ASSIGNMENT_DELAY 2'd0;
	integerParser_isNegative <= `BSV_ASSIGNMENT_DELAY 1'd0;
	integerParser_processedCurrentChar <= `BSV_ASSIGNMENT_DELAY 1'd1;
	ledStatus <= `BSV_ASSIGNMENT_DELAY 16'd0;
	leftInt <= `BSV_ASSIGNMENT_DELAY 18'd0;
	rightInt <= `BSV_ASSIGNMENT_DELAY 18'd0;
	uartBuf <= `BSV_ASSIGNMENT_DELAY 8'd0;
	uartHandler_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 27'd0;
	uartHandler_currentReceivedBit <= `BSV_ASSIGNMENT_DELAY 1'd1;
	uartHandler_inputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY 20'd174762;
	uartHandler_inputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	uartHandler_inputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	uartHandler_outputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY 20'd174762;
	uartHandler_outputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	uartHandler_outputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	uartHandler_receivingData <= `BSV_ASSIGNMENT_DELAY 2'd0;
	uartHandler_toSendBits <= `BSV_ASSIGNMENT_DELAY 12'd682;
      end
    else
      begin
        if (clockDiv_ctr$EN)
	  clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY clockDiv_ctr$D_IN;
	if (currentDigitIndex$EN)
	  currentDigitIndex <= `BSV_ASSIGNMENT_DELAY currentDigitIndex$D_IN;
	if (currentIsSigned$EN)
	  currentIsSigned <= `BSV_ASSIGNMENT_DELAY currentIsSigned$D_IN;
	if (currentNumberS$EN)
	  currentNumberS <= `BSV_ASSIGNMENT_DELAY currentNumberS$D_IN;
	if (currentNumberU$EN)
	  currentNumberU <= `BSV_ASSIGNMENT_DELAY currentNumberU$D_IN;
	if (displayModule_bcdDecodedInput_0$EN)
	  displayModule_bcdDecodedInput_0 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_0$D_IN;
	if (displayModule_bcdDecodedInput_1$EN)
	  displayModule_bcdDecodedInput_1 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_1$D_IN;
	if (displayModule_bcdDecodedInput_2$EN)
	  displayModule_bcdDecodedInput_2 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_2$D_IN;
	if (displayModule_bcdDecodedInput_3$EN)
	  displayModule_bcdDecodedInput_3 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_3$D_IN;
	if (displayModule_clockDiv_ctr$EN)
	  displayModule_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY
	      displayModule_clockDiv_ctr$D_IN;
	if (displayModule_currentDigitIndex$EN)
	  displayModule_currentDigitIndex <= `BSV_ASSIGNMENT_DELAY
	      displayModule_currentDigitIndex$D_IN;
	if (displayModule_isNegative$EN)
	  displayModule_isNegative <= `BSV_ASSIGNMENT_DELAY
	      displayModule_isNegative$D_IN;
	if (displayModule_readyToDisplay$EN)
	  displayModule_readyToDisplay <= `BSV_ASSIGNMENT_DELAY
	      displayModule_readyToDisplay$D_IN;
	if (integerParser_buffer$EN)
	  integerParser_buffer <= `BSV_ASSIGNMENT_DELAY
	      integerParser_buffer$D_IN;
	if (integerParser_currentState$EN)
	  integerParser_currentState <= `BSV_ASSIGNMENT_DELAY
	      integerParser_currentState$D_IN;
	if (integerParser_isNegative$EN)
	  integerParser_isNegative <= `BSV_ASSIGNMENT_DELAY
	      integerParser_isNegative$D_IN;
	if (integerParser_processedCurrentChar$EN)
	  integerParser_processedCurrentChar <= `BSV_ASSIGNMENT_DELAY
	      integerParser_processedCurrentChar$D_IN;
	if (ledStatus$EN) ledStatus <= `BSV_ASSIGNMENT_DELAY ledStatus$D_IN;
	if (leftInt$EN) leftInt <= `BSV_ASSIGNMENT_DELAY leftInt$D_IN;
	if (rightInt$EN) rightInt <= `BSV_ASSIGNMENT_DELAY rightInt$D_IN;
	if (uartBuf$EN) uartBuf <= `BSV_ASSIGNMENT_DELAY uartBuf$D_IN;
	if (uartHandler_clockDiv_ctr$EN)
	  uartHandler_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_clockDiv_ctr$D_IN;
	if (uartHandler_currentReceivedBit$EN)
	  uartHandler_currentReceivedBit <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_currentReceivedBit$D_IN;
	if (uartHandler_inputFIFO_rCache$EN)
	  uartHandler_inputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_inputFIFO_rCache$D_IN;
	if (uartHandler_inputFIFO_rRdPtr$EN)
	  uartHandler_inputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_inputFIFO_rRdPtr$D_IN;
	if (uartHandler_inputFIFO_rWrPtr$EN)
	  uartHandler_inputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_inputFIFO_rWrPtr$D_IN;
	if (uartHandler_outputFIFO_rCache$EN)
	  uartHandler_outputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_outputFIFO_rCache$D_IN;
	if (uartHandler_outputFIFO_rRdPtr$EN)
	  uartHandler_outputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_outputFIFO_rRdPtr$D_IN;
	if (uartHandler_outputFIFO_rWrPtr$EN)
	  uartHandler_outputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_outputFIFO_rWrPtr$D_IN;
	if (uartHandler_receivingData$EN)
	  uartHandler_receivingData <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_receivingData$D_IN;
	if (uartHandler_toSendBits$EN)
	  uartHandler_toSendBits <= `BSV_ASSIGNMENT_DELAY
	      uartHandler_toSendBits$D_IN;
      end
    if (buffer$EN) buffer <= `BSV_ASSIGNMENT_DELAY buffer$D_IN;
    if (displayModule_doubleDabbleCtr$EN)
      displayModule_doubleDabbleCtr <= `BSV_ASSIGNMENT_DELAY
	  displayModule_doubleDabbleCtr$D_IN;
    if (displayModule_toDisplay$EN)
      displayModule_toDisplay <= `BSV_ASSIGNMENT_DELAY
	  displayModule_toDisplay$D_IN;
    if (integerParser_currentBase$EN)
      integerParser_currentBase <= `BSV_ASSIGNMENT_DELAY
	  integerParser_currentBase$D_IN;
    if (integerParser_currentChar$EN)
      integerParser_currentChar <= `BSV_ASSIGNMENT_DELAY
	  integerParser_currentChar$D_IN;
    if (uartHandler_currentRecvIndex$EN)
      uartHandler_currentRecvIndex <= `BSV_ASSIGNMENT_DELAY
	  uartHandler_currentRecvIndex$D_IN;
    if (uartHandler_currentSendIndex$EN)
      uartHandler_currentSendIndex <= `BSV_ASSIGNMENT_DELAY
	  uartHandler_currentSendIndex$D_IN;
    if (uartHandler_receivedBits$EN)
      uartHandler_receivedBits <= `BSV_ASSIGNMENT_DELAY
	  uartHandler_receivedBits$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    buffer = 1'h0;
    clockDiv_ctr = 27'h2AAAAAA;
    currentDigitIndex = 2'h2;
    currentIsSigned = 1'h0;
    currentNumberS = 11'h2AA;
    currentNumberU = 4'hA;
    displayModule_bcdDecodedInput_0 = 4'hA;
    displayModule_bcdDecodedInput_1 = 4'hA;
    displayModule_bcdDecodedInput_2 = 4'hA;
    displayModule_bcdDecodedInput_3 = 4'hA;
    displayModule_clockDiv_ctr = 19'h2AAAA;
    displayModule_currentDigitIndex = 2'h2;
    displayModule_doubleDabbleCtr = 4'hA;
    displayModule_isNegative = 1'h0;
    displayModule_readyToDisplay = 1'h0;
    displayModule_toDisplay = 14'h2AAA;
    integerParser_buffer = 15'h2AAA;
    integerParser_currentBase = 7'h2A;
    integerParser_currentChar = 9'h0AA;
    integerParser_currentState = 2'h2;
    integerParser_isNegative = 1'h0;
    integerParser_processedCurrentChar = 1'h0;
    ledStatus = 16'hAAAA;
    leftInt = 18'h2AAAA;
    rightInt = 18'h2AAAA;
    uartBuf = 8'hAA;
    uartHandler_clockDiv_ctr = 27'h2AAAAAA;
    uartHandler_currentReceivedBit = 1'h0;
    uartHandler_currentRecvIndex = 4'hA;
    uartHandler_currentSendIndex = 4'hA;
    uartHandler_inputFIFO_rCache = 20'hAAAAA;
    uartHandler_inputFIFO_rRdPtr = 11'h2AA;
    uartHandler_inputFIFO_rWrPtr = 11'h2AA;
    uartHandler_outputFIFO_rCache = 20'hAAAAA;
    uartHandler_outputFIFO_rRdPtr = 11'h2AA;
    uartHandler_outputFIFO_rWrPtr = 11'h2AA;
    uartHandler_receivedBits = 9'h0AA;
    uartHandler_receivingData = 2'h2;
    uartHandler_toSendBits = 12'hAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_iterateDigits)
	$display("BCD digit %d: %d",
		 $unsigned(displayModule_currentDigitIndex),
		 $unsigned(SEL_ARR_displayModule_bcdDecodedInput_0_16_dis_ETC___d121));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_iterateDigits &&
	  displayModule_currentDigitIndex == 2'd3)
	$finish(32'd1);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("current i:%o", $unsigned(displayModule_toDisplay));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("readyToDisplay?:%d", displayModule_readyToDisplay);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("current bcd digit #%d: %d",
		 $signed(32'd0),
		 $unsigned(displayModule_bcdDecodedInput_0));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("current bcd digit #%d: %d",
		 $signed(32'd1),
		 $unsigned(displayModule_bcdDecodedInput_1));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("current bcd digit #%d: %d",
		 $signed(32'd2),
		 $unsigned(displayModule_bcdDecodedInput_2));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("current bcd digit #%d: %d",
		 $signed(32'd3),
		 $unsigned(displayModule_bcdDecodedInput_3));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("right int:%d", $unsigned(displayModule_toDisplay));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_displayModule_doubleDabble)
	$display("msb:%d", displayModule_toDisplay[13]);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_integerParser_parsePrefix) $display("parsed prefix");
  end
  // synopsys translate_on
endmodule  // mkTopModule

