//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Fri Jan 26 12:54:36 CET 2018
//
//
// Ports:
// Name                         I/O  size props
// led_ifc_leds                   O    16 reg
// serial_ifc_serialOut           O     1
// display_ifc_disableSegmentsDisplay  O     7
// display_ifc_disableDotDisplay  O     1 const
// display_ifc_disableDigitDisplay  O     4
// CLK                            I     1 clock
// RST_N                          I     1 reset
// buttons_ifc_buttonL_left_input  I     1 reg
// buttons_ifc_buttonR_right_input  I     1 reg
// buttons_ifc_buttonU_upper_input  I     1 reg
// buttons_ifc_buttonD_down_input  I     1 reg
// buttons_ifc_buttonC_center_input  I     1 reg
// switch_ifc_switches_switch_status  I    16
// serial_ifc_serialIn_serial_input  I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTopModule(CLK,
		   RST_N,

		   buttons_ifc_buttonL_left_input,

		   buttons_ifc_buttonR_right_input,

		   buttons_ifc_buttonU_upper_input,

		   buttons_ifc_buttonD_down_input,

		   buttons_ifc_buttonC_center_input,

		   switch_ifc_switches_switch_status,

		   led_ifc_leds,

		   serial_ifc_serialOut,

		   serial_ifc_serialIn_serial_input,

		   display_ifc_disableSegmentsDisplay,

		   display_ifc_disableDotDisplay,

		   display_ifc_disableDigitDisplay);
  input  CLK;
  input  RST_N;

  // action method buttons_ifc_buttonL
  input  buttons_ifc_buttonL_left_input;

  // action method buttons_ifc_buttonR
  input  buttons_ifc_buttonR_right_input;

  // action method buttons_ifc_buttonU
  input  buttons_ifc_buttonU_upper_input;

  // action method buttons_ifc_buttonD
  input  buttons_ifc_buttonD_down_input;

  // action method buttons_ifc_buttonC
  input  buttons_ifc_buttonC_center_input;

  // action method switch_ifc_switches
  input  [15 : 0] switch_ifc_switches_switch_status;

  // value method led_ifc_leds
  output [15 : 0] led_ifc_leds;

  // value method serial_ifc_serialOut
  output serial_ifc_serialOut;

  // action method serial_ifc_serialIn
  input  serial_ifc_serialIn_serial_input;

  // value method display_ifc_disableSegmentsDisplay
  output [6 : 0] display_ifc_disableSegmentsDisplay;

  // value method display_ifc_disableDotDisplay
  output display_ifc_disableDotDisplay;

  // value method display_ifc_disableDigitDisplay
  output [3 : 0] display_ifc_disableDigitDisplay;

  // signals for module outputs
  reg [6 : 0] display_ifc_disableSegmentsDisplay;
  wire [15 : 0] led_ifc_leds;
  wire [3 : 0] display_ifc_disableDigitDisplay;
  wire display_ifc_disableDotDisplay, serial_ifc_serialOut;

  // inlined wires
  wire [32 : 0] tester_s_1_aRandom_prng_seedWire$wget,
		tester_s_1_aRandom_prng_seedWire_1$wget,
		tester_s_1_aRandom_prng_seedWire_2$wget,
		tester_s_2_aRandom_prng_seedWire$wget,
		tester_s_2_aRandom_prng_seedWire_1$wget,
		tester_s_aRandom_prng_seedWire$wget,
		tester_s_aRandom_prng_seedWire_1$wget,
		tester_s_stateGen_seedWire$wget;
  wire [15 : 0] cycler_cyclingFIFO_wDataIn$wget,
		cycler_cyclingFIFO_wDataOut$wget;
  wire tester_s_1_success$wget,
       tester_s_2_success$wget,
       tester_s_didFire$whas,
       tester_s_success$wget,
       tester_start_wire$whas,
       tester_state_set_pw$whas;

  // register bridge_uartHandler_clockDiv_ctr
  reg [26 : 0] bridge_uartHandler_clockDiv_ctr;
  wire [26 : 0] bridge_uartHandler_clockDiv_ctr$D_IN;
  wire bridge_uartHandler_clockDiv_ctr$EN;

  // register bridge_uartHandler_currentReceivedBit
  reg bridge_uartHandler_currentReceivedBit;
  wire bridge_uartHandler_currentReceivedBit$D_IN,
       bridge_uartHandler_currentReceivedBit$EN;

  // register bridge_uartHandler_currentRecvIndex
  reg [3 : 0] bridge_uartHandler_currentRecvIndex;
  wire [3 : 0] bridge_uartHandler_currentRecvIndex$D_IN;
  wire bridge_uartHandler_currentRecvIndex$EN;

  // register bridge_uartHandler_currentSendIndex
  reg [3 : 0] bridge_uartHandler_currentSendIndex;
  wire [3 : 0] bridge_uartHandler_currentSendIndex$D_IN;
  wire bridge_uartHandler_currentSendIndex$EN;

  // register bridge_uartHandler_inputFIFO_rCache
  reg [19 : 0] bridge_uartHandler_inputFIFO_rCache;
  wire [19 : 0] bridge_uartHandler_inputFIFO_rCache$D_IN;
  wire bridge_uartHandler_inputFIFO_rCache$EN;

  // register bridge_uartHandler_inputFIFO_rRdPtr
  reg [10 : 0] bridge_uartHandler_inputFIFO_rRdPtr;
  wire [10 : 0] bridge_uartHandler_inputFIFO_rRdPtr$D_IN;
  wire bridge_uartHandler_inputFIFO_rRdPtr$EN;

  // register bridge_uartHandler_inputFIFO_rWrPtr
  reg [10 : 0] bridge_uartHandler_inputFIFO_rWrPtr;
  wire [10 : 0] bridge_uartHandler_inputFIFO_rWrPtr$D_IN;
  wire bridge_uartHandler_inputFIFO_rWrPtr$EN;

  // register bridge_uartHandler_outputFIFO_rCache
  reg [19 : 0] bridge_uartHandler_outputFIFO_rCache;
  wire [19 : 0] bridge_uartHandler_outputFIFO_rCache$D_IN;
  wire bridge_uartHandler_outputFIFO_rCache$EN;

  // register bridge_uartHandler_outputFIFO_rRdPtr
  reg [10 : 0] bridge_uartHandler_outputFIFO_rRdPtr;
  wire [10 : 0] bridge_uartHandler_outputFIFO_rRdPtr$D_IN;
  wire bridge_uartHandler_outputFIFO_rRdPtr$EN;

  // register bridge_uartHandler_outputFIFO_rWrPtr
  reg [10 : 0] bridge_uartHandler_outputFIFO_rWrPtr;
  wire [10 : 0] bridge_uartHandler_outputFIFO_rWrPtr$D_IN;
  wire bridge_uartHandler_outputFIFO_rWrPtr$EN;

  // register bridge_uartHandler_receivedBits
  reg [8 : 0] bridge_uartHandler_receivedBits;
  wire [8 : 0] bridge_uartHandler_receivedBits$D_IN;
  wire bridge_uartHandler_receivedBits$EN;

  // register bridge_uartHandler_receivingData
  reg [1 : 0] bridge_uartHandler_receivingData;
  reg [1 : 0] bridge_uartHandler_receivingData$D_IN;
  wire bridge_uartHandler_receivingData$EN;

  // register bridge_uartHandler_toSendBits
  reg [11 : 0] bridge_uartHandler_toSendBits;
  wire [11 : 0] bridge_uartHandler_toSendBits$D_IN;
  wire bridge_uartHandler_toSendBits$EN;

  // register bridge_waitRequest
  reg bridge_waitRequest;
  wire bridge_waitRequest$D_IN, bridge_waitRequest$EN;

  // register buttonStatus_0
  reg buttonStatus_0;
  wire buttonStatus_0$D_IN, buttonStatus_0$EN;

  // register buttonStatus_1
  reg buttonStatus_1;
  wire buttonStatus_1$D_IN, buttonStatus_1$EN;

  // register buttonStatus_2
  reg buttonStatus_2;
  wire buttonStatus_2$D_IN, buttonStatus_2$EN;

  // register buttonStatus_3
  reg buttonStatus_3;
  wire buttonStatus_3$D_IN, buttonStatus_3$EN;

  // register buttonStatus_4
  reg buttonStatus_4;
  wire buttonStatus_4$D_IN, buttonStatus_4$EN;

  // register clockDiv_ctr
  reg [27 : 0] clockDiv_ctr;
  wire [27 : 0] clockDiv_ctr$D_IN;
  wire clockDiv_ctr$EN;

  // register currentDigitIndex
  reg [1 : 0] currentDigitIndex;
  wire [1 : 0] currentDigitIndex$D_IN;
  wire currentDigitIndex$EN;

  // register currentIsSigned
  reg currentIsSigned;
  wire currentIsSigned$D_IN, currentIsSigned$EN;

  // register currentNumberS
  reg [10 : 0] currentNumberS;
  wire [10 : 0] currentNumberS$D_IN;
  wire currentNumberS$EN;

  // register currentNumberU
  reg [3 : 0] currentNumberU;
  wire [3 : 0] currentNumberU$D_IN;
  wire currentNumberU$EN;

  // register cycler_clockDiv_ctr
  reg [31 : 0] cycler_clockDiv_ctr;
  wire [31 : 0] cycler_clockDiv_ctr$D_IN;
  wire cycler_clockDiv_ctr$EN;

  // register cycler_cyclingFIFO_rCache
  reg [25 : 0] cycler_cyclingFIFO_rCache;
  wire [25 : 0] cycler_cyclingFIFO_rCache$D_IN;
  wire cycler_cyclingFIFO_rCache$EN;

  // register cycler_cyclingFIFO_rRdPtr
  reg [8 : 0] cycler_cyclingFIFO_rRdPtr;
  wire [8 : 0] cycler_cyclingFIFO_rRdPtr$D_IN;
  wire cycler_cyclingFIFO_rRdPtr$EN;

  // register cycler_cyclingFIFO_rWrPtr
  reg [8 : 0] cycler_cyclingFIFO_rWrPtr;
  wire [8 : 0] cycler_cyclingFIFO_rWrPtr$D_IN;
  wire cycler_cyclingFIFO_rWrPtr$EN;

  // register cycler_displayer_bcdDecodedInput_0
  reg [3 : 0] cycler_displayer_bcdDecodedInput_0;
  wire [3 : 0] cycler_displayer_bcdDecodedInput_0$D_IN;
  wire cycler_displayer_bcdDecodedInput_0$EN;

  // register cycler_displayer_bcdDecodedInput_1
  reg [3 : 0] cycler_displayer_bcdDecodedInput_1;
  wire [3 : 0] cycler_displayer_bcdDecodedInput_1$D_IN;
  wire cycler_displayer_bcdDecodedInput_1$EN;

  // register cycler_displayer_bcdDecodedInput_2
  reg [3 : 0] cycler_displayer_bcdDecodedInput_2;
  wire [3 : 0] cycler_displayer_bcdDecodedInput_2$D_IN;
  wire cycler_displayer_bcdDecodedInput_2$EN;

  // register cycler_displayer_bcdDecodedInput_3
  reg [3 : 0] cycler_displayer_bcdDecodedInput_3;
  wire [3 : 0] cycler_displayer_bcdDecodedInput_3$D_IN;
  wire cycler_displayer_bcdDecodedInput_3$EN;

  // register cycler_displayer_clockDiv_ctr
  reg [18 : 0] cycler_displayer_clockDiv_ctr;
  wire [18 : 0] cycler_displayer_clockDiv_ctr$D_IN;
  wire cycler_displayer_clockDiv_ctr$EN;

  // register cycler_displayer_currentDigitIndex
  reg [1 : 0] cycler_displayer_currentDigitIndex;
  wire [1 : 0] cycler_displayer_currentDigitIndex$D_IN;
  wire cycler_displayer_currentDigitIndex$EN;

  // register cycler_displayer_doubleDabbleCtr
  reg [3 : 0] cycler_displayer_doubleDabbleCtr;
  wire [3 : 0] cycler_displayer_doubleDabbleCtr$D_IN;
  wire cycler_displayer_doubleDabbleCtr$EN;

  // register cycler_displayer_isNegative
  reg cycler_displayer_isNegative;
  wire cycler_displayer_isNegative$D_IN, cycler_displayer_isNegative$EN;

  // register cycler_displayer_readyToDisplay
  reg cycler_displayer_readyToDisplay;
  wire cycler_displayer_readyToDisplay$D_IN,
       cycler_displayer_readyToDisplay$EN;

  // register cycler_displayer_toDisplay
  reg [13 : 0] cycler_displayer_toDisplay;
  wire [13 : 0] cycler_displayer_toDisplay$D_IN;
  wire cycler_displayer_toDisplay$EN;

  // register displayModule_bcdDecodedInput_0
  reg [3 : 0] displayModule_bcdDecodedInput_0;
  wire [3 : 0] displayModule_bcdDecodedInput_0$D_IN;
  wire displayModule_bcdDecodedInput_0$EN;

  // register displayModule_bcdDecodedInput_1
  reg [3 : 0] displayModule_bcdDecodedInput_1;
  wire [3 : 0] displayModule_bcdDecodedInput_1$D_IN;
  wire displayModule_bcdDecodedInput_1$EN;

  // register displayModule_bcdDecodedInput_2
  reg [3 : 0] displayModule_bcdDecodedInput_2;
  wire [3 : 0] displayModule_bcdDecodedInput_2$D_IN;
  wire displayModule_bcdDecodedInput_2$EN;

  // register displayModule_bcdDecodedInput_3
  reg [3 : 0] displayModule_bcdDecodedInput_3;
  wire [3 : 0] displayModule_bcdDecodedInput_3$D_IN;
  wire displayModule_bcdDecodedInput_3$EN;

  // register displayModule_clockDiv_ctr
  reg [18 : 0] displayModule_clockDiv_ctr;
  wire [18 : 0] displayModule_clockDiv_ctr$D_IN;
  wire displayModule_clockDiv_ctr$EN;

  // register displayModule_currentDigitIndex
  reg [1 : 0] displayModule_currentDigitIndex;
  wire [1 : 0] displayModule_currentDigitIndex$D_IN;
  wire displayModule_currentDigitIndex$EN;

  // register displayModule_doubleDabbleCtr
  reg [3 : 0] displayModule_doubleDabbleCtr;
  wire [3 : 0] displayModule_doubleDabbleCtr$D_IN;
  wire displayModule_doubleDabbleCtr$EN;

  // register displayModule_isNegative
  reg displayModule_isNegative;
  wire displayModule_isNegative$D_IN, displayModule_isNegative$EN;

  // register displayModule_readyToDisplay
  reg displayModule_readyToDisplay;
  wire displayModule_readyToDisplay$D_IN, displayModule_readyToDisplay$EN;

  // register displayModule_toDisplay
  reg [13 : 0] displayModule_toDisplay;
  wire [13 : 0] displayModule_toDisplay$D_IN;
  wire displayModule_toDisplay$EN;

  // register ledStatus
  reg [15 : 0] ledStatus;
  wire [15 : 0] ledStatus$D_IN;
  wire ledStatus$EN;

  // register leftInt_holdsNewValue
  reg leftInt_holdsNewValue;
  wire leftInt_holdsNewValue$D_IN, leftInt_holdsNewValue$EN;

  // register leftInt_valueHolder
  reg [31 : 0] leftInt_valueHolder;
  wire [31 : 0] leftInt_valueHolder$D_IN;
  wire leftInt_valueHolder$EN;

  // register rightInt_holdsNewValue
  reg rightInt_holdsNewValue;
  wire rightInt_holdsNewValue$D_IN, rightInt_holdsNewValue$EN;

  // register rightInt_valueHolder
  reg [31 : 0] rightInt_valueHolder;
  wire [31 : 0] rightInt_valueHolder$D_IN;
  wire rightInt_valueHolder$EN;

  // register tester_running
  reg tester_running;
  wire tester_running$D_IN, tester_running$EN;

  // register tester_s_1_aRandom_prng_state
  reg [30 : 0] tester_s_1_aRandom_prng_state;
  wire [30 : 0] tester_s_1_aRandom_prng_state$D_IN;
  wire tester_s_1_aRandom_prng_state$EN;

  // register tester_s_1_aRandom_prng_state_1
  reg [30 : 0] tester_s_1_aRandom_prng_state_1;
  wire [30 : 0] tester_s_1_aRandom_prng_state_1$D_IN;
  wire tester_s_1_aRandom_prng_state_1$EN;

  // register tester_s_1_aRandom_prng_state_2
  reg [30 : 0] tester_s_1_aRandom_prng_state_2;
  wire [30 : 0] tester_s_1_aRandom_prng_state_2$D_IN;
  wire tester_s_1_aRandom_prng_state_2$EN;

  // register tester_s_1_aReg
  reg [3 : 0] tester_s_1_aReg;
  wire [3 : 0] tester_s_1_aReg$D_IN;
  wire tester_s_1_aReg$EN;

  // register tester_s_1_aReg_1
  reg [3 : 0] tester_s_1_aReg_1;
  wire [3 : 0] tester_s_1_aReg_1$D_IN;
  wire tester_s_1_aReg_1$EN;

  // register tester_s_1_aReg_2
  reg [3 : 0] tester_s_1_aReg_2;
  wire [3 : 0] tester_s_1_aReg_2$D_IN;
  wire tester_s_1_aReg_2$EN;

  // register tester_s_2_aRandom_prng_state
  reg [30 : 0] tester_s_2_aRandom_prng_state;
  wire [30 : 0] tester_s_2_aRandom_prng_state$D_IN;
  wire tester_s_2_aRandom_prng_state$EN;

  // register tester_s_2_aRandom_prng_state_1
  reg [30 : 0] tester_s_2_aRandom_prng_state_1;
  wire [30 : 0] tester_s_2_aRandom_prng_state_1$D_IN;
  wire tester_s_2_aRandom_prng_state_1$EN;

  // register tester_s_2_aReg
  reg [3 : 0] tester_s_2_aReg;
  wire [3 : 0] tester_s_2_aReg$D_IN;
  wire tester_s_2_aReg$EN;

  // register tester_s_2_aReg_1
  reg [3 : 0] tester_s_2_aReg_1;
  wire [3 : 0] tester_s_2_aReg_1$D_IN;
  wire tester_s_2_aReg_1$EN;

  // register tester_s_aRandom_prng_state
  reg [30 : 0] tester_s_aRandom_prng_state;
  wire [30 : 0] tester_s_aRandom_prng_state$D_IN;
  wire tester_s_aRandom_prng_state$EN;

  // register tester_s_aRandom_prng_state_1
  reg [30 : 0] tester_s_aRandom_prng_state_1;
  wire [30 : 0] tester_s_aRandom_prng_state_1$D_IN;
  wire tester_s_aRandom_prng_state_1$EN;

  // register tester_s_aReg
  reg [3 : 0] tester_s_aReg;
  wire [3 : 0] tester_s_aReg$D_IN;
  wire tester_s_aReg$EN;

  // register tester_s_aReg_1
  reg [3 : 0] tester_s_aReg_1;
  wire [3 : 0] tester_s_aReg_1$D_IN;
  wire tester_s_aReg_1$EN;

  // register tester_s_chatty
  reg tester_s_chatty;
  wire tester_s_chatty$D_IN, tester_s_chatty$EN;

  // register tester_s_consecutiveNonFires
  reg [15 : 0] tester_s_consecutiveNonFires;
  wire [15 : 0] tester_s_consecutiveNonFires$D_IN;
  wire tester_s_consecutiveNonFires$EN;

  // register tester_s_count
  reg [31 : 0] tester_s_count;
  wire [31 : 0] tester_s_count$D_IN;
  wire tester_s_count$EN;

  // register tester_s_counterExampleLen
  reg [31 : 0] tester_s_counterExampleLen;
  wire [31 : 0] tester_s_counterExampleLen$D_IN;
  wire tester_s_counterExampleLen$EN;

  // register tester_s_currentDepth
  reg [31 : 0] tester_s_currentDepth;
  wire [31 : 0] tester_s_currentDepth$D_IN;
  wire tester_s_currentDepth$EN;

  // register tester_s_delayedCount
  reg [31 : 0] tester_s_delayedCount;
  wire [31 : 0] tester_s_delayedCount$D_IN;
  wire tester_s_delayedCount$EN;

  // register tester_s_deleteNum
  reg [32 : 0] tester_s_deleteNum;
  wire [32 : 0] tester_s_deleteNum$D_IN;
  wire tester_s_deleteNum$EN;

  // register tester_s_doneUI
  reg tester_s_doneUI;
  wire tester_s_doneUI$D_IN, tester_s_doneUI$EN;

  // register tester_s_failureReg
  reg tester_s_failureReg;
  wire tester_s_failureReg$D_IN, tester_s_failureReg$EN;

  // register tester_s_gotPlusArgs
  reg tester_s_gotPlusArgs;
  wire tester_s_gotPlusArgs$D_IN, tester_s_gotPlusArgs$EN;

  // register tester_s_iterCount
  reg [31 : 0] tester_s_iterCount;
  wire [31 : 0] tester_s_iterCount$D_IN;
  wire tester_s_iterCount$EN;

  // register tester_s_loopDone
  reg tester_s_loopDone;
  wire tester_s_loopDone$D_IN, tester_s_loopDone$EN;

  // register tester_s_nibbleCount
  reg [3 : 0] tester_s_nibbleCount;
  wire [3 : 0] tester_s_nibbleCount$D_IN;
  wire tester_s_nibbleCount$EN;

  // register tester_s_omitNum
  reg [31 : 0] tester_s_omitNum;
  wire [31 : 0] tester_s_omitNum$D_IN;
  wire tester_s_omitNum$EN;

  // register tester_s_prePostActive
  reg tester_s_prePostActive;
  wire tester_s_prePostActive$D_IN, tester_s_prePostActive$EN;

  // register tester_s_resumeFlag
  reg tester_s_resumeFlag;
  wire tester_s_resumeFlag$D_IN, tester_s_resumeFlag$EN;

  // register tester_s_resumed
  reg tester_s_resumed;
  wire tester_s_resumed$D_IN, tester_s_resumed$EN;

  // register tester_s_seedFile
  reg [31 : 0] tester_s_seedFile;
  wire [31 : 0] tester_s_seedFile$D_IN;
  wire tester_s_seedFile$EN;

  // register tester_s_seeded
  reg tester_s_seeded;
  wire tester_s_seeded$D_IN, tester_s_seeded$EN;

  // register tester_s_shadows_regs
  reg [31 : 0] tester_s_shadows_regs;
  wire [31 : 0] tester_s_shadows_regs$D_IN;
  wire tester_s_shadows_regs$EN;

  // register tester_s_shadows_regs_1
  reg [31 : 0] tester_s_shadows_regs_1;
  wire [31 : 0] tester_s_shadows_regs_1$D_IN;
  wire tester_s_shadows_regs_1$EN;

  // register tester_s_shadows_regs_2
  reg [31 : 0] tester_s_shadows_regs_2;
  wire [31 : 0] tester_s_shadows_regs_2$D_IN;
  wire tester_s_shadows_regs_2$EN;

  // register tester_s_shadows_regs_3
  reg [31 : 0] tester_s_shadows_regs_3;
  wire [31 : 0] tester_s_shadows_regs_3$D_IN;
  wire tester_s_shadows_regs_3$EN;

  // register tester_s_shadows_regs_4
  reg [31 : 0] tester_s_shadows_regs_4;
  wire [31 : 0] tester_s_shadows_regs_4$D_IN;
  wire tester_s_shadows_regs_4$EN;

  // register tester_s_shadows_regs_5
  reg [31 : 0] tester_s_shadows_regs_5;
  wire [31 : 0] tester_s_shadows_regs_5$D_IN;
  wire tester_s_shadows_regs_5$EN;

  // register tester_s_shadows_regs_6
  reg [31 : 0] tester_s_shadows_regs_6;
  wire [31 : 0] tester_s_shadows_regs_6$D_IN;
  wire tester_s_shadows_regs_6$EN;

  // register tester_s_shadows_regs_7
  reg [31 : 0] tester_s_shadows_regs_7;
  wire [31 : 0] tester_s_shadows_regs_7$D_IN;
  wire tester_s_shadows_regs_7$EN;

  // register tester_s_startTime
  reg [31 : 0] tester_s_startTime;
  wire [31 : 0] tester_s_startTime$D_IN;
  wire tester_s_startTime$EN;

  // register tester_s_state
  reg [15 : 0] tester_s_state;
  wire [15 : 0] tester_s_state$D_IN;
  wire tester_s_state$EN;

  // register tester_s_stateGen_state
  reg [30 : 0] tester_s_stateGen_state;
  wire [30 : 0] tester_s_stateGen_state$D_IN;
  wire tester_s_stateGen_state$EN;

  // register tester_s_testDone
  reg tester_s_testDone;
  wire tester_s_testDone$D_IN, tester_s_testDone$EN;

  // register tester_s_testNum
  reg [31 : 0] tester_s_testNum;
  wire [31 : 0] tester_s_testNum$D_IN;
  wire tester_s_testNum$EN;

  // register tester_s_timer
  reg [31 : 0] tester_s_timer;
  wire [31 : 0] tester_s_timer$D_IN;
  wire tester_s_timer$EN;

  // register tester_s_tmpReg
  reg [31 : 0] tester_s_tmpReg;
  wire [31 : 0] tester_s_tmpReg$D_IN;
  wire tester_s_tmpReg$EN;

  // register tester_s_triggerView
  reg tester_s_triggerView;
  wire tester_s_triggerView$D_IN, tester_s_triggerView$EN;

  // register tester_s_verbose
  reg tester_s_verbose;
  wire tester_s_verbose$D_IN, tester_s_verbose$EN;

  // register tester_s_viewFlag
  reg tester_s_viewFlag;
  wire tester_s_viewFlag$D_IN, tester_s_viewFlag$EN;

  // register tester_s_wedgeDetected
  reg tester_s_wedgeDetected;
  wire tester_s_wedgeDetected$D_IN, tester_s_wedgeDetected$EN;

  // register tester_start_reg
  reg tester_start_reg;
  wire tester_start_reg$D_IN, tester_start_reg$EN;

  // register tester_start_reg_1
  reg tester_start_reg_1;
  wire tester_start_reg_1$D_IN, tester_start_reg_1$EN;

  // register tester_state_can_overlap
  reg tester_state_can_overlap;
  wire tester_state_can_overlap$D_IN, tester_state_can_overlap$EN;

  // register tester_state_fired
  reg tester_state_fired;
  wire tester_state_fired$D_IN, tester_state_fired$EN;

  // register tester_state_mkFSMstate
  reg [3 : 0] tester_state_mkFSMstate;
  reg [3 : 0] tester_state_mkFSMstate$D_IN;
  wire tester_state_mkFSMstate$EN;

  // register tester_uart_reading
  reg tester_uart_reading;
  wire tester_uart_reading$D_IN, tester_uart_reading$EN;

  // ports of submodule bridge_uartHandler_inputFIFO_memory
  wire [9 : 0] bridge_uartHandler_inputFIFO_memory$ADDRA,
	       bridge_uartHandler_inputFIFO_memory$ADDRB;
  wire [7 : 0] bridge_uartHandler_inputFIFO_memory$DIA,
	       bridge_uartHandler_inputFIFO_memory$DIB,
	       bridge_uartHandler_inputFIFO_memory$DOB;
  wire bridge_uartHandler_inputFIFO_memory$ENA,
       bridge_uartHandler_inputFIFO_memory$ENB,
       bridge_uartHandler_inputFIFO_memory$WEA,
       bridge_uartHandler_inputFIFO_memory$WEB;

  // ports of submodule bridge_uartHandler_outputFIFO_memory
  wire [9 : 0] bridge_uartHandler_outputFIFO_memory$ADDRA,
	       bridge_uartHandler_outputFIFO_memory$ADDRB;
  wire [7 : 0] bridge_uartHandler_outputFIFO_memory$DIA,
	       bridge_uartHandler_outputFIFO_memory$DIB;
  wire bridge_uartHandler_outputFIFO_memory$ENA,
       bridge_uartHandler_outputFIFO_memory$ENB,
       bridge_uartHandler_outputFIFO_memory$WEA,
       bridge_uartHandler_outputFIFO_memory$WEB;

  // ports of submodule cycler_cyclingFIFO_memory
  wire [15 : 0] cycler_cyclingFIFO_memory$DIA,
		cycler_cyclingFIFO_memory$DIB,
		cycler_cyclingFIFO_memory$DOB;
  wire [7 : 0] cycler_cyclingFIFO_memory$ADDRA,
	       cycler_cyclingFIFO_memory$ADDRB;
  wire cycler_cyclingFIFO_memory$ENA,
       cycler_cyclingFIFO_memory$ENB,
       cycler_cyclingFIFO_memory$WEA,
       cycler_cyclingFIFO_memory$WEB;

  // ports of submodule tester_out
  wire [7 : 0] tester_out$D_IN, tester_out$D_OUT;
  wire tester_out$CLR, tester_out$DEQ, tester_out$EMPTY_N, tester_out$ENQ;

  // ports of submodule tester_s_timeFIFO
  wire [32 : 0] tester_s_timeFIFO$D_IN;
  wire tester_s_timeFIFO$CLR, tester_s_timeFIFO$DEQ, tester_s_timeFIFO$ENQ;

  // rule scheduling signals
  wire WILL_FIRE_RL_bridge_letWait,
       WILL_FIRE_RL_bridge_uartHandler_advanceSend,
       WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO,
       WILL_FIRE_RL_bridge_uartHandler_prepareForOut,
       WILL_FIRE_RL_bridge_uartHandler_startReceiving,
       WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit,
       WILL_FIRE_RL_cycler_cycle,
       WILL_FIRE_RL_cycler_displayer_doubleDabble,
       WILL_FIRE_RL_tester_action_l1684c7,
       WILL_FIRE_RL_tester_action_l1724c21,
       WILL_FIRE_RL_tester_action_l1729c9,
       WILL_FIRE_RL_tester_fsm_start,
       WILL_FIRE_RL_tester_idle_l1682c5,
       WILL_FIRE_RL_tester_s_checkInvariantBool;

  // inputs to muxes for submodule ports
  reg [3 : 0] MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_1,
	      MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_1,
	      MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_1;
  wire [31 : 0] MUX_tester_s_count$write_1__VAL_1;
  wire [13 : 0] MUX_cycler_displayer_toDisplay$write_1__VAL_1,
		MUX_cycler_displayer_toDisplay$write_1__VAL_2;
  wire [11 : 0] MUX_bridge_uartHandler_toSendBits$write_1__VAL_2;
  wire [3 : 0] MUX_bridge_uartHandler_currentRecvIndex$write_1__VAL_1,
	       MUX_bridge_uartHandler_currentSendIndex$write_1__VAL_1,
	       MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_2,
	       MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_2,
	       MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_2,
	       MUX_cycler_displayer_bcdDecodedInput_3$write_1__VAL_1,
	       MUX_cycler_displayer_bcdDecodedInput_3$write_1__VAL_2,
	       MUX_cycler_displayer_doubleDabbleCtr$write_1__VAL_2;
  wire MUX_bridge_uartHandler_receivingData$write_1__SEL_1,
       MUX_bridge_uartHandler_toSendBits$write_1__SEL_1,
       MUX_cycler_displayer_bcdDecodedInput_0$write_1__SEL_1,
       MUX_cycler_displayer_bcdDecodedInput_1$write_1__SEL_1,
       MUX_cycler_displayer_bcdDecodedInput_2$write_1__SEL_1,
       MUX_cycler_displayer_bcdDecodedInput_3$write_1__SEL_1,
       MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1,
       MUX_cycler_displayer_readyToDisplay$write_1__VAL_1,
       MUX_tester_s_count$write_1__SEL_1,
       MUX_tester_s_prePostActive$write_1__SEL_1,
       MUX_tester_s_testDone$write_1__SEL_1,
       MUX_tester_start_reg$write_1__SEL_2;

  // remaining internal signals
  reg [3 : 0] CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q5,
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216,
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_3_ETC___d231,
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_5_ETC___d244,
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_7_ETC___d263,
	      SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72,
	      SEL_ARR_displayModule_bcdDecodedInput_0_0_disp_ETC___d15;
  reg [1 : 0] CASE_cycler_cyclingFIFO_memoryDOB_BITS_15_TO__ETC__q4,
	      CASE_cycler_cyclingFIFO_rCache_BITS_15_TO_14_0_ETC__q3,
	      CASE_cycler_cyclingFIFO_wDataInwget_BITS_15_T_ETC__q7,
	      CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q6;
  reg TASK_testplusargs___d280,
      TASK_testplusargs___d281,
      TASK_testplusargs___d283,
      TASK_testplusargs___d284;
  wire [61 : 0] tester_s_1_aRandom_prng_state_1_37_MUL_1103515245___d338,
		tester_s_1_aRandom_prng_state_24_MUL_1103515245___d325,
		tester_s_1_aRandom_prng_state_2_50_MUL_1103515245___d351,
		tester_s_2_aRandom_prng_state_1_84_MUL_1103515245___d385,
		tester_s_2_aRandom_prng_state_71_MUL_1103515245___d372,
		tester_s_aRandom_prng_state_1_06_MUL_1103515245___d307,
		tester_s_aRandom_prng_state_93_MUL_1103515245___d294,
		tester_s_stateGen_state_02_MUL_1103515245___d403;
  wire [31 : 0] x__h24100, x__h69973;
  wire [30 : 0] x__h15013,
		x__h15895,
		x__h17199,
		x__h18081,
		x__h18963,
		x__h20202,
		x__h20974,
		x__h21968;
  wire [15 : 0] IF_NOT_cycler_cyclingFIFO_wDataIn_whas__25_26__ETC___d139;
  wire [10 : 0] IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d205,
		bridge_uartHandler_toSendBits_BITS_10_TO_0__q1,
		x__h73215,
		x__h73317,
		x__h74177,
		x__h74279;
  wire [8 : 0] x__h75426, x__h7600, x__h7712, y__h75476;
  wire [7 : 0] spliced_bits__h74984, x3__h73132, x3__h74096;
  wire [3 : 0] IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214,
	       IF_cycler_displayer_bcdDecodedInput_0_7_ULE_4__ETC___d80,
	       IF_cycler_displayer_bcdDecodedInput_1_8_ULE_4__ETC___d89,
	       IF_cycler_displayer_bcdDecodedInput_2_9_ULE_4__ETC___d97,
	       IF_cycler_displayer_bcdDecodedInput_3_ULE_4_TH_ETC__q2,
	       IF_displayModule_bcdDecodedInput_0_0_ULE_4_1_T_ETC___d23,
	       IF_displayModule_bcdDecodedInput_1_1_ULE_4_0_T_ETC___d32,
	       IF_displayModule_bcdDecodedInput_2_2_ULE_4_8_T_ETC___d40,
	       IF_displayModule_bcdDecodedInput_3_ULE_4_THEN__ETC__q8,
	       x__h76621;
  wire IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206,
       NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d826,
       NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d831,
       NOT_tester_s_delayedCount_read__16_EQ_0_17_18__ETC___d648,
       NOT_tester_s_success_whas__20_58_OR_tester_s_s_ETC___d665,
       NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644,
       NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d436,
       NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687,
       _dfoo1,
       cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210,
       cycler_cyclingFIFO_wDataOut_wget__90_BITS_15_T_ETC___d261,
       tester_abort_whas__96_AND_tester_abort_wget__9_ETC___d694,
       tester_s_count_read__10_ULT_1000___d651,
       tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456,
       tester_s_success_whas__20_AND_NOT_tester_s_suc_ETC___d433;

  // value method led_ifc_leds
  assign led_ifc_leds = ledStatus ;

  // value method serial_ifc_serialOut
  assign serial_ifc_serialOut =
	     !bridge_uartHandler_toSendBits[11] ||
	     bridge_uartHandler_toSendBits_BITS_10_TO_0__q1[bridge_uartHandler_currentSendIndex] ;

  // value method display_ifc_disableSegmentsDisplay
  always@(SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72)
  begin
    case (SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72)
      4'd0: display_ifc_disableSegmentsDisplay = 7'b1000000;
      4'd1: display_ifc_disableSegmentsDisplay = 7'b1111001;
      4'd2: display_ifc_disableSegmentsDisplay = 7'b0100100;
      4'd3: display_ifc_disableSegmentsDisplay = 7'b0110000;
      4'd4: display_ifc_disableSegmentsDisplay = 7'b0011001;
      4'd5: display_ifc_disableSegmentsDisplay = 7'b0010010;
      4'd6: display_ifc_disableSegmentsDisplay = 7'b0000010;
      4'd7: display_ifc_disableSegmentsDisplay = 7'b1111000;
      4'd8: display_ifc_disableSegmentsDisplay = 7'b0;
      4'd9: display_ifc_disableSegmentsDisplay = 7'b0010000;
      4'd10: display_ifc_disableSegmentsDisplay = 7'b0111111;
      4'd11: display_ifc_disableSegmentsDisplay = 7'b1110111;
      default: display_ifc_disableSegmentsDisplay = 7'b1111111;
    endcase
  end

  // value method display_ifc_disableDotDisplay
  assign display_ifc_disableDotDisplay = 1'd1 ;

  // value method display_ifc_disableDigitDisplay
  assign display_ifc_disableDigitDisplay =
	     cycler_displayer_readyToDisplay ? ~x__h76621 : 4'd1 ;

  // submodule bridge_uartHandler_inputFIFO_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd10),
	  .DATA_WIDTH(32'd8),
	  .MEMSIZE(11'd1024)) bridge_uartHandler_inputFIFO_memory(.CLKA(CLK),
								  .CLKB(CLK),
								  .ADDRA(bridge_uartHandler_inputFIFO_memory$ADDRA),
								  .ADDRB(bridge_uartHandler_inputFIFO_memory$ADDRB),
								  .DIA(bridge_uartHandler_inputFIFO_memory$DIA),
								  .DIB(bridge_uartHandler_inputFIFO_memory$DIB),
								  .WEA(bridge_uartHandler_inputFIFO_memory$WEA),
								  .WEB(bridge_uartHandler_inputFIFO_memory$WEB),
								  .ENA(bridge_uartHandler_inputFIFO_memory$ENA),
								  .ENB(bridge_uartHandler_inputFIFO_memory$ENB),
								  .DOA(),
								  .DOB(bridge_uartHandler_inputFIFO_memory$DOB));

  // submodule bridge_uartHandler_outputFIFO_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd10),
	  .DATA_WIDTH(32'd8),
	  .MEMSIZE(11'd1024)) bridge_uartHandler_outputFIFO_memory(.CLKA(CLK),
								   .CLKB(CLK),
								   .ADDRA(bridge_uartHandler_outputFIFO_memory$ADDRA),
								   .ADDRB(bridge_uartHandler_outputFIFO_memory$ADDRB),
								   .DIA(bridge_uartHandler_outputFIFO_memory$DIA),
								   .DIB(bridge_uartHandler_outputFIFO_memory$DIB),
								   .WEA(bridge_uartHandler_outputFIFO_memory$WEA),
								   .WEB(bridge_uartHandler_outputFIFO_memory$WEB),
								   .ENA(bridge_uartHandler_outputFIFO_memory$ENA),
								   .ENB(bridge_uartHandler_outputFIFO_memory$ENB),
								   .DOA(),
								   .DOB());

  // submodule cycler_cyclingFIFO_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd8),
	  .DATA_WIDTH(32'd16),
	  .MEMSIZE(9'd256)) cycler_cyclingFIFO_memory(.CLKA(CLK),
						      .CLKB(CLK),
						      .ADDRA(cycler_cyclingFIFO_memory$ADDRA),
						      .ADDRB(cycler_cyclingFIFO_memory$ADDRB),
						      .DIA(cycler_cyclingFIFO_memory$DIA),
						      .DIB(cycler_cyclingFIFO_memory$DIB),
						      .WEA(cycler_cyclingFIFO_memory$WEA),
						      .WEB(cycler_cyclingFIFO_memory$WEB),
						      .ENA(cycler_cyclingFIFO_memory$ENA),
						      .ENB(cycler_cyclingFIFO_memory$ENB),
						      .DOA(),
						      .DOB(cycler_cyclingFIFO_memory$DOB));

  // submodule tester_out
  FIFO2 #(.width(32'd8), .guarded(32'd0)) tester_out(.RST(RST_N),
						     .CLK(CLK),
						     .D_IN(tester_out$D_IN),
						     .ENQ(tester_out$ENQ),
						     .DEQ(tester_out$DEQ),
						     .CLR(tester_out$CLR),
						     .D_OUT(tester_out$D_OUT),
						     .FULL_N(),
						     .EMPTY_N(tester_out$EMPTY_N));

  // submodule tester_s_timeFIFO
  SizedFIFO #(.p1width(32'd33),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(32'd1)) tester_s_timeFIFO(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(tester_s_timeFIFO$D_IN),
						 .ENQ(tester_s_timeFIFO$ENQ),
						 .DEQ(tester_s_timeFIFO$DEQ),
						 .CLR(tester_s_timeFIFO$CLR),
						 .D_OUT(),
						 .FULL_N(),
						 .EMPTY_N());

  // rule RL_cycler_displayer_doubleDabble
  assign WILL_FIRE_RL_cycler_displayer_doubleDabble =
	     cycler_displayer_doubleDabbleCtr < 4'd14 &&
	     !cycler_displayer_readyToDisplay ;

  // rule RL_cycler_cycle
  assign WILL_FIRE_RL_cycler_cycle =
	     cycler_cyclingFIFO_rRdPtr != cycler_cyclingFIFO_rWrPtr &&
	     cycler_cyclingFIFO_rRdPtr + 9'd128 !=
	     cycler_cyclingFIFO_rWrPtr &&
	     cycler_clockDiv_ctr == 32'd0 ;

  // rule RL_tester_fsm_start
  assign WILL_FIRE_RL_tester_fsm_start =
	     tester_abort_whas__96_AND_tester_abort_wget__9_ETC___d694 &&
	     tester_start_reg ;

  // rule RL_tester_idle_l1682c5
  assign WILL_FIRE_RL_tester_idle_l1682c5 =
	     !tester_start_wire$whas && tester_state_mkFSMstate == 4'd11 ;

  // rule RL_tester_s_checkInvariantBool
  assign WILL_FIRE_RL_tester_s_checkInvariantBool =
	     tester_s_delayedCount != 32'd0 && !tester_s_failureReg ;

  // rule RL_tester_action_l1729c9
  assign WILL_FIRE_RL_tester_action_l1729c9 =
	     (tester_s_delayedCount == 32'd0 ||
	      NOT_tester_s_success_whas__20_58_OR_tester_s_s_ETC___d665) &&
	     !tester_s_failureReg &&
	     tester_state_mkFSMstate == 4'd9 ;

  // rule RL_tester_action_l1684c7
  assign WILL_FIRE_RL_tester_action_l1684c7 =
	     tester_s_seeded && tester_start_wire$whas &&
	     (tester_state_mkFSMstate == 4'd0 ||
	      tester_state_mkFSMstate == 4'd11) ;

  // rule RL_tester_action_l1724c21
  assign WILL_FIRE_RL_tester_action_l1724c21 =
	     tester_s_testDone &&
	     (tester_state_mkFSMstate == 4'd5 ||
	      tester_state_mkFSMstate == 4'd6) ;

  // rule RL_bridge_letWait
  assign WILL_FIRE_RL_bridge_letWait =
	     bridge_uartHandler_inputFIFO_rRdPtr + 11'd512 !=
	     bridge_uartHandler_inputFIFO_rWrPtr &&
	     !bridge_waitRequest ;

  // rule RL_bridge_uartHandler_advanceSend
  assign WILL_FIRE_RL_bridge_uartHandler_advanceSend =
	     bridge_uartHandler_toSendBits[11] &&
	     bridge_uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_bridge_uartHandler_startReceiving
  assign WILL_FIRE_RL_bridge_uartHandler_startReceiving =
	     !bridge_uartHandler_currentReceivedBit &&
	     bridge_uartHandler_receivingData == 2'd0 &&
	     bridge_uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_bridge_uartHandler_writeReceivedBit
  assign WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit =
	     bridge_uartHandler_receivingData == 2'd1 &&
	     bridge_uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_bridge_uartHandler_enterIntoFIFO
  assign WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO =
	     bridge_uartHandler_outputFIFO_rRdPtr + 11'd512 !=
	     bridge_uartHandler_outputFIFO_rWrPtr &&
	     bridge_uartHandler_receivingData == 2'd2 &&
	     bridge_uartHandler_clockDiv_ctr == 27'd0 ;

  // rule RL_bridge_uartHandler_prepareForOut
  assign WILL_FIRE_RL_bridge_uartHandler_prepareForOut =
	     bridge_uartHandler_inputFIFO_rRdPtr !=
	     bridge_uartHandler_inputFIFO_rWrPtr &&
	     !bridge_uartHandler_toSendBits[11] &&
	     bridge_uartHandler_clockDiv_ctr == 27'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_bridge_uartHandler_receivingData$write_1__SEL_1 =
	     WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit &&
	     bridge_uartHandler_currentRecvIndex == 4'd7 ;
  assign MUX_bridge_uartHandler_toSendBits$write_1__SEL_1 =
	     WILL_FIRE_RL_bridge_uartHandler_advanceSend &&
	     bridge_uartHandler_currentSendIndex == 4'd10 ;
  assign MUX_cycler_displayer_bcdDecodedInput_0$write_1__SEL_1 =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ;
  assign MUX_cycler_displayer_bcdDecodedInput_1$write_1__SEL_1 =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[3:2] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[3:2] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[3:2] == 2'd2)) ;
  assign MUX_cycler_displayer_bcdDecodedInput_2$write_1__SEL_1 =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[5:4] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[5:4] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[5:4] == 2'd2)) ;
  assign MUX_cycler_displayer_bcdDecodedInput_3$write_1__SEL_1 =
	     WILL_FIRE_RL_cycler_cycle && _dfoo1 ;
  assign MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1 =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1) &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd1 ||
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206) &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd0 ||
	      cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210) ;
  assign MUX_tester_s_count$write_1__SEL_1 =
	     NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 &&
	     (NOT_tester_s_delayedCount_read__16_EQ_0_17_18__ETC___d648 ||
	      tester_s_didFire$whas) ;
  assign MUX_tester_s_prePostActive$write_1__SEL_1 =
	     tester_state_mkFSMstate == 4'd8 ||
	     tester_state_mkFSMstate == 4'd3 ;
  assign MUX_tester_s_testDone$write_1__SEL_1 =
	     NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 &&
	     (NOT_tester_s_delayedCount_read__16_EQ_0_17_18__ETC___d648 ||
	      tester_s_didFire$whas &&
	      !tester_s_count_read__10_ULT_1000___d651) ;
  assign MUX_tester_start_reg$write_1__SEL_2 =
	     tester_abort_whas__96_AND_tester_abort_wget__9_ETC___d694 &&
	     !tester_start_reg &&
	     !tester_running ;
  assign MUX_bridge_uartHandler_currentRecvIndex$write_1__VAL_1 =
	     bridge_uartHandler_currentRecvIndex + 4'd1 ;
  assign MUX_bridge_uartHandler_currentSendIndex$write_1__VAL_1 =
	     bridge_uartHandler_currentSendIndex + 4'd1 ;
  assign MUX_bridge_uartHandler_toSendBits$write_1__VAL_2 =
	     { 3'd7, spliced_bits__h74984, 1'd0 } ;
  always@(cycler_cyclingFIFO_wDataOut$wget or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216 or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[15:14])
      2'd0, 2'd1:
	  MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214;
      default: MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_1 =
		   IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216;
    endcase
  end
  assign MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_2 =
	     { IF_cycler_displayer_bcdDecodedInput_0_7_ULE_4__ETC___d80[2:0],
	       1'd0 } +
	     { 3'd0, cycler_displayer_toDisplay[13] } ;
  always@(cycler_cyclingFIFO_wDataOut$wget or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_3_ETC___d231 or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214 or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[15:14])
      2'd0, 2'd1:
	  MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214;
      2'd2:
	  MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216;
      2'd3:
	  MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_3_ETC___d231;
    endcase
  end
  assign MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_2 =
	     { IF_cycler_displayer_bcdDecodedInput_1_8_ULE_4__ETC___d89[2:0],
	       1'd0 } +
	     { 3'd0,
	       IF_cycler_displayer_bcdDecodedInput_0_7_ULE_4__ETC___d80[3] } ;
  always@(cycler_cyclingFIFO_wDataOut$wget or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_5_ETC___d244 or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214 or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[15:14])
      2'd0, 2'd1:
	  MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214;
      2'd2:
	  MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216;
      2'd3:
	  MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_1 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_5_ETC___d244;
    endcase
  end
  assign MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_2 =
	     { IF_cycler_displayer_bcdDecodedInput_2_9_ULE_4__ETC___d97[2:0],
	       1'd0 } +
	     { 3'd0,
	       IF_cycler_displayer_bcdDecodedInput_1_8_ULE_4__ETC___d89[3] } ;
  assign MUX_cycler_displayer_bcdDecodedInput_3$write_1__VAL_1 =
	     cycler_cyclingFIFO_wDataOut_wget__90_BITS_15_T_ETC___d261 ?
	       CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q5 :
	       ((cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 &&
		 cycler_cyclingFIFO_wDataOut$wget[10]) ?
		  4'd10 :
		  4'd0) ;
  assign MUX_cycler_displayer_bcdDecodedInput_3$write_1__VAL_2 =
	     cycler_displayer_isNegative ?
	       cycler_displayer_bcdDecodedInput_3 :
	       { IF_cycler_displayer_bcdDecodedInput_3_ULE_4_TH_ETC__q2[2:0],
		 1'd0 } +
	       { 3'd0,
		 IF_cycler_displayer_bcdDecodedInput_2_9_ULE_4__ETC___d97[3] } ;
  assign MUX_cycler_displayer_doubleDabbleCtr$write_1__VAL_2 =
	     cycler_displayer_doubleDabbleCtr + 4'd1 ;
  assign MUX_cycler_displayer_readyToDisplay$write_1__VAL_1 =
	     cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd0 &&
	     cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd1 ||
	     cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 &&
	     !IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206 ||
	     cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 &&
	     !cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210 ;
  assign MUX_cycler_displayer_toDisplay$write_1__VAL_1 =
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0) ?
	       cycler_cyclingFIFO_wDataOut$wget[13:0] :
	       { 3'd0,
		 IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d205 } ;
  assign MUX_cycler_displayer_toDisplay$write_1__VAL_2 =
	     { cycler_displayer_toDisplay[12:0], 1'd0 } ;
  assign MUX_tester_s_count$write_1__VAL_1 =
	     NOT_tester_s_delayedCount_read__16_EQ_0_17_18__ETC___d648 ?
	       32'd0 :
	       (tester_s_count_read__10_ULT_1000___d651 ? x__h69973 : 32'd0) ;

  // inlined wires
  assign cycler_cyclingFIFO_wDataIn$wget =
	     { CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q6,
	       cycler_cyclingFIFO_wDataOut$wget[13:0] } ;
  assign cycler_cyclingFIFO_wDataOut$wget =
	     (cycler_cyclingFIFO_rCache[25] &&
	      cycler_cyclingFIFO_rCache[24:16] == cycler_cyclingFIFO_rRdPtr) ?
	       { CASE_cycler_cyclingFIFO_rCache_BITS_15_TO_14_0_ETC__q3,
		 cycler_cyclingFIFO_rCache[13:0] } :
	       { CASE_cycler_cyclingFIFO_memoryDOB_BITS_15_TO__ETC__q4,
		 cycler_cyclingFIFO_memory$DOB[13:0] } ;
  assign tester_s_aRandom_prng_seedWire$wget = 33'h100000002 ;
  assign tester_s_aRandom_prng_seedWire_1$wget = 33'h100000003 ;
  assign tester_s_success$wget =
	     tester_s_aReg + tester_s_aReg_1 ==
	     tester_s_aReg_1 + tester_s_aReg ;
  assign tester_s_1_aRandom_prng_seedWire$wget = 33'h100000004 ;
  assign tester_s_1_aRandom_prng_seedWire_1$wget = 33'h100000005 ;
  assign tester_s_1_aRandom_prng_seedWire_2$wget = 33'h100000006 ;
  assign tester_s_1_success$wget =
	     tester_s_1_aReg + tester_s_1_aReg_1 + tester_s_1_aReg_2 ==
	     tester_s_1_aReg + tester_s_1_aReg_1 + tester_s_1_aReg_2 ;
  assign tester_s_2_aRandom_prng_seedWire$wget = 33'h100000007 ;
  assign tester_s_2_aRandom_prng_seedWire_1$wget = 33'h100000008 ;
  assign tester_s_2_success$wget =
	     tester_s_2_aReg - tester_s_2_aReg_1 ==
	     tester_s_2_aReg_1 - tester_s_2_aReg ;
  assign tester_s_stateGen_seedWire$wget = 33'h100000001 ;
  assign tester_start_wire$whas =
	     WILL_FIRE_RL_tester_fsm_start ||
	     tester_start_reg_1 && !tester_state_fired ;
  assign tester_s_didFire$whas =
	     tester_s_count != 32'd0 && tester_s_state == 16'd0 ;
  assign tester_state_set_pw$whas =
	     WILL_FIRE_RL_tester_idle_l1682c5 ||
	     NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687 ||
	     WILL_FIRE_RL_tester_action_l1729c9 ||
	     tester_state_mkFSMstate == 4'd8 ||
	     tester_state_mkFSMstate == 4'd7 ||
	     WILL_FIRE_RL_tester_action_l1724c21 ||
	     NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	     tester_state_mkFSMstate == 4'd4 ||
	     tester_state_mkFSMstate == 4'd3 ||
	     tester_state_mkFSMstate == 4'd2 ||
	     tester_state_mkFSMstate == 4'd1 ||
	     WILL_FIRE_RL_tester_action_l1684c7 ;

  // register bridge_uartHandler_clockDiv_ctr
  assign bridge_uartHandler_clockDiv_ctr$D_IN =
	     (bridge_uartHandler_clockDiv_ctr < 27'd10415) ?
	       bridge_uartHandler_clockDiv_ctr + 27'd1 :
	       27'd0 ;
  assign bridge_uartHandler_clockDiv_ctr$EN = 1'd1 ;

  // register bridge_uartHandler_currentReceivedBit
  assign bridge_uartHandler_currentReceivedBit$D_IN =
	     serial_ifc_serialIn_serial_input ;
  assign bridge_uartHandler_currentReceivedBit$EN = 1'd1 ;

  // register bridge_uartHandler_currentRecvIndex
  assign bridge_uartHandler_currentRecvIndex$D_IN =
	     WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit ?
	       MUX_bridge_uartHandler_currentRecvIndex$write_1__VAL_1 :
	       4'd0 ;
  assign bridge_uartHandler_currentRecvIndex$EN =
	     WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit ||
	     WILL_FIRE_RL_bridge_uartHandler_startReceiving ;

  // register bridge_uartHandler_currentSendIndex
  assign bridge_uartHandler_currentSendIndex$D_IN =
	     WILL_FIRE_RL_bridge_uartHandler_advanceSend ?
	       MUX_bridge_uartHandler_currentSendIndex$write_1__VAL_1 :
	       4'd0 ;
  assign bridge_uartHandler_currentSendIndex$EN =
	     WILL_FIRE_RL_bridge_uartHandler_advanceSend ||
	     WILL_FIRE_RL_bridge_uartHandler_prepareForOut ;

  // register bridge_uartHandler_inputFIFO_rCache
  assign bridge_uartHandler_inputFIFO_rCache$D_IN =
	     { 1'd1, bridge_uartHandler_inputFIFO_rWrPtr, x3__h73132 } ;
  assign bridge_uartHandler_inputFIFO_rCache$EN =
	     WILL_FIRE_RL_bridge_letWait ;

  // register bridge_uartHandler_inputFIFO_rRdPtr
  assign bridge_uartHandler_inputFIFO_rRdPtr$D_IN = x__h73317 ;
  assign bridge_uartHandler_inputFIFO_rRdPtr$EN =
	     WILL_FIRE_RL_bridge_uartHandler_prepareForOut ;

  // register bridge_uartHandler_inputFIFO_rWrPtr
  assign bridge_uartHandler_inputFIFO_rWrPtr$D_IN = x__h73215 ;
  assign bridge_uartHandler_inputFIFO_rWrPtr$EN =
	     WILL_FIRE_RL_bridge_letWait ;

  // register bridge_uartHandler_outputFIFO_rCache
  assign bridge_uartHandler_outputFIFO_rCache$D_IN =
	     { 1'd1, bridge_uartHandler_outputFIFO_rWrPtr, x3__h74096 } ;
  assign bridge_uartHandler_outputFIFO_rCache$EN =
	     WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO ;

  // register bridge_uartHandler_outputFIFO_rRdPtr
  assign bridge_uartHandler_outputFIFO_rRdPtr$D_IN = x__h74279 ;
  assign bridge_uartHandler_outputFIFO_rRdPtr$EN = 1'b0 ;

  // register bridge_uartHandler_outputFIFO_rWrPtr
  assign bridge_uartHandler_outputFIFO_rWrPtr$D_IN = x__h74177 ;
  assign bridge_uartHandler_outputFIFO_rWrPtr$EN =
	     WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO ;

  // register bridge_uartHandler_receivedBits
  assign bridge_uartHandler_receivedBits$D_IN =
	     bridge_uartHandler_currentReceivedBit ?
	       bridge_uartHandler_receivedBits | x__h75426 :
	       bridge_uartHandler_receivedBits & y__h75476 ;
  assign bridge_uartHandler_receivedBits$EN =
	     WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit ;

  // register bridge_uartHandler_receivingData
  always@(MUX_bridge_uartHandler_receivingData$write_1__SEL_1 or
	  WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO or
	  WILL_FIRE_RL_bridge_uartHandler_startReceiving)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_bridge_uartHandler_receivingData$write_1__SEL_1:
	  bridge_uartHandler_receivingData$D_IN = 2'd2;
      WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO:
	  bridge_uartHandler_receivingData$D_IN = 2'd0;
      WILL_FIRE_RL_bridge_uartHandler_startReceiving:
	  bridge_uartHandler_receivingData$D_IN = 2'd1;
      default: bridge_uartHandler_receivingData$D_IN =
		   2'b10 /* unspecified value */ ;
    endcase
  end
  assign bridge_uartHandler_receivingData$EN =
	     WILL_FIRE_RL_bridge_uartHandler_writeReceivedBit &&
	     bridge_uartHandler_currentRecvIndex == 4'd7 ||
	     WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO ||
	     WILL_FIRE_RL_bridge_uartHandler_startReceiving ;

  // register bridge_uartHandler_toSendBits
  assign bridge_uartHandler_toSendBits$D_IN =
	     MUX_bridge_uartHandler_toSendBits$write_1__SEL_1 ?
	       12'd682 :
	       MUX_bridge_uartHandler_toSendBits$write_1__VAL_2 ;
  assign bridge_uartHandler_toSendBits$EN =
	     WILL_FIRE_RL_bridge_uartHandler_advanceSend &&
	     bridge_uartHandler_currentSendIndex == 4'd10 ||
	     WILL_FIRE_RL_bridge_uartHandler_prepareForOut ;

  // register bridge_waitRequest
  assign bridge_waitRequest$D_IN = !bridge_waitRequest ;
  assign bridge_waitRequest$EN =
	     bridge_waitRequest || WILL_FIRE_RL_bridge_letWait ;

  // register buttonStatus_0
  assign buttonStatus_0$D_IN = buttons_ifc_buttonL_left_input ;
  assign buttonStatus_0$EN = 1'd1 ;

  // register buttonStatus_1
  assign buttonStatus_1$D_IN = buttons_ifc_buttonR_right_input ;
  assign buttonStatus_1$EN = 1'd1 ;

  // register buttonStatus_2
  assign buttonStatus_2$D_IN = buttons_ifc_buttonU_upper_input ;
  assign buttonStatus_2$EN = 1'd1 ;

  // register buttonStatus_3
  assign buttonStatus_3$D_IN = buttons_ifc_buttonD_down_input ;
  assign buttonStatus_3$EN = 1'd1 ;

  // register buttonStatus_4
  assign buttonStatus_4$D_IN = buttons_ifc_buttonC_center_input ;
  assign buttonStatus_4$EN = 1'd1 ;

  // register clockDiv_ctr
  assign clockDiv_ctr$D_IN = clockDiv_ctr + 28'd1 ;
  assign clockDiv_ctr$EN = 1'd1 ;

  // register currentDigitIndex
  assign currentDigitIndex$D_IN = 2'h0 ;
  assign currentDigitIndex$EN = 1'b0 ;

  // register currentIsSigned
  assign currentIsSigned$D_IN = 1'b0 ;
  assign currentIsSigned$EN = 1'b0 ;

  // register currentNumberS
  assign currentNumberS$D_IN = 11'h0 ;
  assign currentNumberS$EN = 1'b0 ;

  // register currentNumberU
  assign currentNumberU$D_IN = 4'h0 ;
  assign currentNumberU$EN = 1'b0 ;

  // register cycler_clockDiv_ctr
  assign cycler_clockDiv_ctr$D_IN =
	     (cycler_clockDiv_ctr < 32'd33554431) ?
	       cycler_clockDiv_ctr + 32'd1 :
	       32'd0 ;
  assign cycler_clockDiv_ctr$EN = 1'd1 ;

  // register cycler_cyclingFIFO_rCache
  assign cycler_cyclingFIFO_rCache$D_IN =
	     { 1'd1,
	       cycler_cyclingFIFO_rWrPtr,
	       IF_NOT_cycler_cyclingFIFO_wDataIn_whas__25_26__ETC___d139 } ;
  assign cycler_cyclingFIFO_rCache$EN = WILL_FIRE_RL_cycler_cycle ;

  // register cycler_cyclingFIFO_rRdPtr
  assign cycler_cyclingFIFO_rRdPtr$D_IN = x__h7712 ;
  assign cycler_cyclingFIFO_rRdPtr$EN = WILL_FIRE_RL_cycler_cycle ;

  // register cycler_cyclingFIFO_rWrPtr
  assign cycler_cyclingFIFO_rWrPtr$D_IN = x__h7600 ;
  assign cycler_cyclingFIFO_rWrPtr$EN = WILL_FIRE_RL_cycler_cycle ;

  // register cycler_displayer_bcdDecodedInput_0
  assign cycler_displayer_bcdDecodedInput_0$D_IN =
	     MUX_cycler_displayer_bcdDecodedInput_0$write_1__SEL_1 ?
	       MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_1 :
	       MUX_cycler_displayer_bcdDecodedInput_0$write_1__VAL_2 ;
  assign cycler_displayer_bcdDecodedInput_0$EN =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ||
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ;

  // register cycler_displayer_bcdDecodedInput_1
  assign cycler_displayer_bcdDecodedInput_1$D_IN =
	     MUX_cycler_displayer_bcdDecodedInput_1$write_1__SEL_1 ?
	       MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_1 :
	       MUX_cycler_displayer_bcdDecodedInput_1$write_1__VAL_2 ;
  assign cycler_displayer_bcdDecodedInput_1$EN =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[3:2] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[3:2] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[3:2] == 2'd2)) ||
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ;

  // register cycler_displayer_bcdDecodedInput_2
  assign cycler_displayer_bcdDecodedInput_2$D_IN =
	     MUX_cycler_displayer_bcdDecodedInput_2$write_1__SEL_1 ?
	       MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_1 :
	       MUX_cycler_displayer_bcdDecodedInput_2$write_1__VAL_2 ;
  assign cycler_displayer_bcdDecodedInput_2$EN =
	     WILL_FIRE_RL_cycler_cycle &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[5:4] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[5:4] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[5:4] == 2'd2)) ||
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ;

  // register cycler_displayer_bcdDecodedInput_3
  assign cycler_displayer_bcdDecodedInput_3$D_IN =
	     MUX_cycler_displayer_bcdDecodedInput_3$write_1__SEL_1 ?
	       MUX_cycler_displayer_bcdDecodedInput_3$write_1__VAL_1 :
	       MUX_cycler_displayer_bcdDecodedInput_3$write_1__VAL_2 ;
  assign cycler_displayer_bcdDecodedInput_3$EN =
	     WILL_FIRE_RL_cycler_cycle && _dfoo1 ||
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ;

  // register cycler_displayer_clockDiv_ctr
  assign cycler_displayer_clockDiv_ctr$D_IN =
	     cycler_displayer_clockDiv_ctr + 19'd1 ;
  assign cycler_displayer_clockDiv_ctr$EN = 1'd1 ;

  // register cycler_displayer_currentDigitIndex
  assign cycler_displayer_currentDigitIndex$D_IN =
	     cycler_displayer_currentDigitIndex + 2'd1 ;
  assign cycler_displayer_currentDigitIndex$EN =
	     cycler_displayer_readyToDisplay &&
	     cycler_displayer_clockDiv_ctr == 19'd0 ;

  // register cycler_displayer_doubleDabbleCtr
  assign cycler_displayer_doubleDabbleCtr$D_IN =
	     MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1 ?
	       4'd0 :
	       MUX_cycler_displayer_doubleDabbleCtr$write_1__VAL_2 ;
  assign cycler_displayer_doubleDabbleCtr$EN =
	     MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1 ||
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ;

  // register cycler_displayer_isNegative
  assign cycler_displayer_isNegative$D_IN =
	     cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 &&
	     cycler_cyclingFIFO_wDataOut$wget[10] ;
  assign cycler_displayer_isNegative$EN =
	     MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1 ;

  // register cycler_displayer_readyToDisplay
  assign cycler_displayer_readyToDisplay$D_IN =
	     WILL_FIRE_RL_cycler_cycle ?
	       MUX_cycler_displayer_readyToDisplay$write_1__VAL_1 :
	       cycler_displayer_doubleDabbleCtr == 4'd13 ;
  assign cycler_displayer_readyToDisplay$EN =
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ||
	     WILL_FIRE_RL_cycler_cycle ;

  // register cycler_displayer_toDisplay
  assign cycler_displayer_toDisplay$D_IN =
	     MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1 ?
	       MUX_cycler_displayer_toDisplay$write_1__VAL_1 :
	       MUX_cycler_displayer_toDisplay$write_1__VAL_2 ;
  assign cycler_displayer_toDisplay$EN =
	     MUX_cycler_displayer_doubleDabbleCtr$write_1__SEL_1 ||
	     WILL_FIRE_RL_cycler_displayer_doubleDabble ;

  // register displayModule_bcdDecodedInput_0
  assign displayModule_bcdDecodedInput_0$D_IN =
	     { IF_displayModule_bcdDecodedInput_0_0_ULE_4_1_T_ETC___d23[2:0],
	       1'd0 } +
	     { 3'd0, displayModule_toDisplay[13] } ;
  assign displayModule_bcdDecodedInput_0$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register displayModule_bcdDecodedInput_1
  assign displayModule_bcdDecodedInput_1$D_IN =
	     { IF_displayModule_bcdDecodedInput_1_1_ULE_4_0_T_ETC___d32[2:0],
	       1'd0 } +
	     { 3'd0,
	       IF_displayModule_bcdDecodedInput_0_0_ULE_4_1_T_ETC___d23[3] } ;
  assign displayModule_bcdDecodedInput_1$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register displayModule_bcdDecodedInput_2
  assign displayModule_bcdDecodedInput_2$D_IN =
	     { IF_displayModule_bcdDecodedInput_2_2_ULE_4_8_T_ETC___d40[2:0],
	       1'd0 } +
	     { 3'd0,
	       IF_displayModule_bcdDecodedInput_1_1_ULE_4_0_T_ETC___d32[3] } ;
  assign displayModule_bcdDecodedInput_2$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register displayModule_bcdDecodedInput_3
  assign displayModule_bcdDecodedInput_3$D_IN =
	     displayModule_isNegative ?
	       displayModule_bcdDecodedInput_3 :
	       { IF_displayModule_bcdDecodedInput_3_ULE_4_THEN__ETC__q8[2:0],
		 1'd0 } +
	       { 3'd0,
		 IF_displayModule_bcdDecodedInput_2_2_ULE_4_8_T_ETC___d40[3] } ;
  assign displayModule_bcdDecodedInput_3$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register displayModule_clockDiv_ctr
  assign displayModule_clockDiv_ctr$D_IN =
	     displayModule_clockDiv_ctr + 19'd1 ;
  assign displayModule_clockDiv_ctr$EN = 1'd1 ;

  // register displayModule_currentDigitIndex
  assign displayModule_currentDigitIndex$D_IN =
	     displayModule_currentDigitIndex + 2'd1 ;
  assign displayModule_currentDigitIndex$EN =
	     displayModule_readyToDisplay &&
	     displayModule_clockDiv_ctr == 19'd0 ;

  // register displayModule_doubleDabbleCtr
  assign displayModule_doubleDabbleCtr$D_IN =
	     displayModule_doubleDabbleCtr + 4'd1 ;
  assign displayModule_doubleDabbleCtr$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register displayModule_isNegative
  assign displayModule_isNegative$D_IN = 1'b0 ;
  assign displayModule_isNegative$EN = 1'b0 ;

  // register displayModule_readyToDisplay
  assign displayModule_readyToDisplay$D_IN =
	     displayModule_doubleDabbleCtr == 4'd13 ;
  assign displayModule_readyToDisplay$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register displayModule_toDisplay
  assign displayModule_toDisplay$D_IN =
	     { displayModule_toDisplay[12:0], 1'd0 } ;
  assign displayModule_toDisplay$EN =
	     displayModule_doubleDabbleCtr < 4'd14 &&
	     !displayModule_readyToDisplay ;

  // register ledStatus
  assign ledStatus$D_IN = switch_ifc_switches_switch_status ;
  assign ledStatus$EN = 1'd1 ;

  // register leftInt_holdsNewValue
  assign leftInt_holdsNewValue$D_IN = 1'd1 ;
  assign leftInt_holdsNewValue$EN =
	     NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d826 ;

  // register leftInt_valueHolder
  assign leftInt_valueHolder$D_IN =
	     { 24'd0, switch_ifc_switches_switch_status[15:8] } ;
  assign leftInt_valueHolder$EN =
	     NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d826 ;

  // register rightInt_holdsNewValue
  assign rightInt_holdsNewValue$D_IN = 1'd1 ;
  assign rightInt_holdsNewValue$EN =
	     NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d831 ;

  // register rightInt_valueHolder
  assign rightInt_valueHolder$D_IN =
	     { 24'd0, switch_ifc_switches_switch_status[7:0] } ;
  assign rightInt_valueHolder$EN =
	     NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d831 ;

  // register tester_running
  assign tester_running$D_IN = 1'd1 ;
  assign tester_running$EN = MUX_tester_start_reg$write_1__SEL_2 ;

  // register tester_s_1_aRandom_prng_state
  assign tester_s_1_aRandom_prng_state$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_1_aRandom_prng_seedWire$wget[30:0] :
	       x__h17199 ;
  assign tester_s_1_aRandom_prng_state$EN = 1'b1 ;

  // register tester_s_1_aRandom_prng_state_1
  assign tester_s_1_aRandom_prng_state_1$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_1_aRandom_prng_seedWire_1$wget[30:0] :
	       x__h18081 ;
  assign tester_s_1_aRandom_prng_state_1$EN = 1'b1 ;

  // register tester_s_1_aRandom_prng_state_2
  assign tester_s_1_aRandom_prng_state_2$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_1_aRandom_prng_seedWire_2$wget[30:0] :
	       x__h18963 ;
  assign tester_s_1_aRandom_prng_state_2$EN = 1'b1 ;

  // register tester_s_1_aReg
  assign tester_s_1_aReg$D_IN =
	     { tester_s_1_aRandom_prng_state[27],
	       tester_s_1_aRandom_prng_state[28],
	       tester_s_1_aRandom_prng_state[29],
	       tester_s_1_aRandom_prng_state[30] } ;
  assign tester_s_1_aReg$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_1_aReg_1
  assign tester_s_1_aReg_1$D_IN =
	     { tester_s_1_aRandom_prng_state_1[27],
	       tester_s_1_aRandom_prng_state_1[28],
	       tester_s_1_aRandom_prng_state_1[29],
	       tester_s_1_aRandom_prng_state_1[30] } ;
  assign tester_s_1_aReg_1$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_1_aReg_2
  assign tester_s_1_aReg_2$D_IN =
	     { tester_s_1_aRandom_prng_state_2[27],
	       tester_s_1_aRandom_prng_state_2[28],
	       tester_s_1_aRandom_prng_state_2[29],
	       tester_s_1_aRandom_prng_state_2[30] } ;
  assign tester_s_1_aReg_2$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_2_aRandom_prng_state
  assign tester_s_2_aRandom_prng_state$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_2_aRandom_prng_seedWire$wget[30:0] :
	       x__h20202 ;
  assign tester_s_2_aRandom_prng_state$EN = 1'b1 ;

  // register tester_s_2_aRandom_prng_state_1
  assign tester_s_2_aRandom_prng_state_1$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_2_aRandom_prng_seedWire_1$wget[30:0] :
	       x__h20974 ;
  assign tester_s_2_aRandom_prng_state_1$EN = 1'b1 ;

  // register tester_s_2_aReg
  assign tester_s_2_aReg$D_IN =
	     { tester_s_2_aRandom_prng_state[27],
	       tester_s_2_aRandom_prng_state[28],
	       tester_s_2_aRandom_prng_state[29],
	       tester_s_2_aRandom_prng_state[30] } ;
  assign tester_s_2_aReg$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_2_aReg_1
  assign tester_s_2_aReg_1$D_IN =
	     { tester_s_2_aRandom_prng_state_1[27],
	       tester_s_2_aRandom_prng_state_1[28],
	       tester_s_2_aRandom_prng_state_1[29],
	       tester_s_2_aRandom_prng_state_1[30] } ;
  assign tester_s_2_aReg_1$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_aRandom_prng_state
  assign tester_s_aRandom_prng_state$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_aRandom_prng_seedWire$wget[30:0] :
	       x__h15013 ;
  assign tester_s_aRandom_prng_state$EN = 1'b1 ;

  // register tester_s_aRandom_prng_state_1
  assign tester_s_aRandom_prng_state_1$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_aRandom_prng_seedWire_1$wget[30:0] :
	       x__h15895 ;
  assign tester_s_aRandom_prng_state_1$EN = 1'b1 ;

  // register tester_s_aReg
  assign tester_s_aReg$D_IN =
	     { tester_s_aRandom_prng_state[27],
	       tester_s_aRandom_prng_state[28],
	       tester_s_aRandom_prng_state[29],
	       tester_s_aRandom_prng_state[30] } ;
  assign tester_s_aReg$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_aReg_1
  assign tester_s_aReg_1$D_IN =
	     { tester_s_aRandom_prng_state_1[27],
	       tester_s_aRandom_prng_state_1[28],
	       tester_s_aRandom_prng_state_1[29],
	       tester_s_aRandom_prng_state_1[30] } ;
  assign tester_s_aReg_1$EN =
	     tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 ;

  // register tester_s_chatty
  assign tester_s_chatty$D_IN = TASK_testplusargs___d284 ;
  assign tester_s_chatty$EN = !tester_s_gotPlusArgs ;

  // register tester_s_consecutiveNonFires
  assign tester_s_consecutiveNonFires$D_IN = 16'h0 ;
  assign tester_s_consecutiveNonFires$EN = 1'b0 ;

  // register tester_s_count
  assign tester_s_count$D_IN =
	     MUX_tester_s_count$write_1__SEL_1 ?
	       MUX_tester_s_count$write_1__VAL_1 :
	       32'd1 ;
  assign tester_s_count$EN =
	     NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 &&
	     (NOT_tester_s_delayedCount_read__16_EQ_0_17_18__ETC___d648 ||
	      tester_s_didFire$whas) ||
	     tester_state_mkFSMstate == 4'd4 ;

  // register tester_s_counterExampleLen
  assign tester_s_counterExampleLen$D_IN = 32'h0 ;
  assign tester_s_counterExampleLen$EN = 1'b0 ;

  // register tester_s_currentDepth
  assign tester_s_currentDepth$D_IN = 32'h0 ;
  assign tester_s_currentDepth$EN = 1'b0 ;

  // register tester_s_delayedCount
  assign tester_s_delayedCount$D_IN = tester_s_count ;
  assign tester_s_delayedCount$EN = 1'd1 ;

  // register tester_s_deleteNum
  assign tester_s_deleteNum$D_IN = 33'h0 ;
  assign tester_s_deleteNum$EN = 1'b0 ;

  // register tester_s_doneUI
  assign tester_s_doneUI$D_IN = 1'b0 ;
  assign tester_s_doneUI$EN = 1'b0 ;

  // register tester_s_failureReg
  assign tester_s_failureReg$D_IN = 1'b1 ;
  assign tester_s_failureReg$EN =
	     NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d436 ;

  // register tester_s_gotPlusArgs
  assign tester_s_gotPlusArgs$D_IN = 1'd1 ;
  assign tester_s_gotPlusArgs$EN = !tester_s_gotPlusArgs ;

  // register tester_s_iterCount
  assign tester_s_iterCount$D_IN = 32'h0 ;
  assign tester_s_iterCount$EN = 1'b0 ;

  // register tester_s_loopDone
  assign tester_s_loopDone$D_IN = 1'b0 ;
  assign tester_s_loopDone$EN = 1'b0 ;

  // register tester_s_nibbleCount
  assign tester_s_nibbleCount$D_IN = 4'h0 ;
  assign tester_s_nibbleCount$EN = 1'b0 ;

  // register tester_s_omitNum
  assign tester_s_omitNum$D_IN = 32'h0 ;
  assign tester_s_omitNum$EN = 1'b0 ;

  // register tester_s_prePostActive
  assign tester_s_prePostActive$D_IN =
	     !MUX_tester_s_prePostActive$write_1__SEL_1 ;
  assign tester_s_prePostActive$EN =
	     tester_state_mkFSMstate == 4'd8 ||
	     tester_state_mkFSMstate == 4'd3 ||
	     WILL_FIRE_RL_tester_action_l1724c21 ||
	     tester_state_mkFSMstate == 4'd1 ;

  // register tester_s_resumeFlag
  assign tester_s_resumeFlag$D_IN =
	     TASK_testplusargs___d280 || TASK_testplusargs___d281 ;
  assign tester_s_resumeFlag$EN = !tester_s_gotPlusArgs ;

  // register tester_s_resumed
  assign tester_s_resumed$D_IN = 1'b0 ;
  assign tester_s_resumed$EN = 1'b0 ;

  // register tester_s_seedFile
  assign tester_s_seedFile$D_IN = 32'h0 ;
  assign tester_s_seedFile$EN = 1'b0 ;

  // register tester_s_seeded
  assign tester_s_seeded$D_IN = 1'd1 ;
  assign tester_s_seeded$EN = !tester_s_seeded ;

  // register tester_s_shadows_regs
  assign tester_s_shadows_regs$D_IN = tester_s_shadows_regs_7 ;
  assign tester_s_shadows_regs$EN = 1'b0 ;

  // register tester_s_shadows_regs_1
  assign tester_s_shadows_regs_1$D_IN = tester_s_shadows_regs ;
  assign tester_s_shadows_regs_1$EN = 1'b0 ;

  // register tester_s_shadows_regs_2
  assign tester_s_shadows_regs_2$D_IN = tester_s_shadows_regs_1 ;
  assign tester_s_shadows_regs_2$EN = 1'b0 ;

  // register tester_s_shadows_regs_3
  assign tester_s_shadows_regs_3$D_IN = tester_s_shadows_regs_2 ;
  assign tester_s_shadows_regs_3$EN = 1'b0 ;

  // register tester_s_shadows_regs_4
  assign tester_s_shadows_regs_4$D_IN = tester_s_shadows_regs_3 ;
  assign tester_s_shadows_regs_4$EN = 1'b0 ;

  // register tester_s_shadows_regs_5
  assign tester_s_shadows_regs_5$D_IN = tester_s_shadows_regs_4 ;
  assign tester_s_shadows_regs_5$EN = 1'b0 ;

  // register tester_s_shadows_regs_6
  assign tester_s_shadows_regs_6$D_IN = tester_s_shadows_regs_5 ;
  assign tester_s_shadows_regs_6$EN = 1'b0 ;

  // register tester_s_shadows_regs_7
  assign tester_s_shadows_regs_7$D_IN = tester_s_shadows_regs_6 ;
  assign tester_s_shadows_regs_7$EN = 1'b0 ;

  // register tester_s_startTime
  assign tester_s_startTime$D_IN = 32'h0 ;
  assign tester_s_startTime$EN = 1'b0 ;

  // register tester_s_state
  assign tester_s_state$D_IN = 16'd0 ;
  assign tester_s_state$EN =
	     NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 &&
	     (tester_s_delayedCount == 32'd0 ||
	      NOT_tester_s_success_whas__20_58_OR_tester_s_s_ETC___d665) &&
	     !tester_s_failureReg ;

  // register tester_s_stateGen_state
  assign tester_s_stateGen_state$D_IN =
	     (!tester_s_seeded) ?
	       tester_s_stateGen_seedWire$wget[30:0] :
	       x__h21968 ;
  assign tester_s_stateGen_state$EN = 1'b1 ;

  // register tester_s_testDone
  assign tester_s_testDone$D_IN = MUX_tester_s_testDone$write_1__SEL_1 ;
  assign tester_s_testDone$EN =
	     MUX_tester_s_testDone$write_1__SEL_1 ||
	     WILL_FIRE_RL_tester_action_l1684c7 ;

  // register tester_s_testNum
  assign tester_s_testNum$D_IN = 32'h0 ;
  assign tester_s_testNum$EN = 1'b0 ;

  // register tester_s_timer
  assign tester_s_timer$D_IN =
	     WILL_FIRE_RL_tester_action_l1684c7 ? 32'd0 : x__h24100 ;
  assign tester_s_timer$EN = 1'd1 ;

  // register tester_s_tmpReg
  assign tester_s_tmpReg$D_IN = 32'h0 ;
  assign tester_s_tmpReg$EN = 1'b0 ;

  // register tester_s_triggerView
  assign tester_s_triggerView$D_IN = 1'b0 ;
  assign tester_s_triggerView$EN = 1'd1 ;

  // register tester_s_verbose
  assign tester_s_verbose$D_IN = 1'd1 ;
  assign tester_s_verbose$EN = WILL_FIRE_RL_tester_action_l1684c7 ;

  // register tester_s_viewFlag
  assign tester_s_viewFlag$D_IN = TASK_testplusargs___d283 ;
  assign tester_s_viewFlag$EN = !tester_s_gotPlusArgs ;

  // register tester_s_wedgeDetected
  assign tester_s_wedgeDetected$D_IN = 1'b1 ;
  assign tester_s_wedgeDetected$EN = 1'b0 ;

  // register tester_start_reg
  assign tester_start_reg$D_IN = !WILL_FIRE_RL_tester_fsm_start ;
  assign tester_start_reg$EN =
	     WILL_FIRE_RL_tester_fsm_start ||
	     tester_abort_whas__96_AND_tester_abort_wget__9_ETC___d694 &&
	     !tester_start_reg &&
	     !tester_running ;

  // register tester_start_reg_1
  assign tester_start_reg_1$D_IN = tester_start_wire$whas ;
  assign tester_start_reg_1$EN = 1'd1 ;

  // register tester_state_can_overlap
  assign tester_state_can_overlap$D_IN =
	     tester_state_set_pw$whas || tester_state_can_overlap ;
  assign tester_state_can_overlap$EN = 1'd1 ;

  // register tester_state_fired
  assign tester_state_fired$D_IN = tester_state_set_pw$whas ;
  assign tester_state_fired$EN = 1'd1 ;

  // register tester_state_mkFSMstate
  always@(WILL_FIRE_RL_tester_idle_l1682c5 or
	  WILL_FIRE_RL_tester_action_l1684c7 or
	  tester_state_mkFSMstate or
	  NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 or
	  WILL_FIRE_RL_tester_action_l1724c21 or
	  WILL_FIRE_RL_tester_action_l1729c9 or
	  NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_tester_idle_l1682c5: tester_state_mkFSMstate$D_IN = 4'd0;
      WILL_FIRE_RL_tester_action_l1684c7: tester_state_mkFSMstate$D_IN = 4'd1;
      tester_state_mkFSMstate == 4'd1: tester_state_mkFSMstate$D_IN = 4'd2;
      tester_state_mkFSMstate == 4'd2: tester_state_mkFSMstate$D_IN = 4'd3;
      tester_state_mkFSMstate == 4'd3: tester_state_mkFSMstate$D_IN = 4'd4;
      tester_state_mkFSMstate == 4'd4: tester_state_mkFSMstate$D_IN = 4'd5;
      NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644:
	  tester_state_mkFSMstate$D_IN = 4'd6;
      WILL_FIRE_RL_tester_action_l1724c21:
	  tester_state_mkFSMstate$D_IN = 4'd7;
      tester_state_mkFSMstate == 4'd7: tester_state_mkFSMstate$D_IN = 4'd8;
      tester_state_mkFSMstate == 4'd8: tester_state_mkFSMstate$D_IN = 4'd9;
      WILL_FIRE_RL_tester_action_l1729c9:
	  tester_state_mkFSMstate$D_IN = 4'd10;
      NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687:
	  tester_state_mkFSMstate$D_IN = 4'd11;
      default: tester_state_mkFSMstate$D_IN =
		   4'b1010 /* unspecified value */ ;
    endcase
  end
  assign tester_state_mkFSMstate$EN =
	     WILL_FIRE_RL_tester_idle_l1682c5 ||
	     WILL_FIRE_RL_tester_action_l1684c7 ||
	     tester_state_mkFSMstate == 4'd1 ||
	     tester_state_mkFSMstate == 4'd2 ||
	     tester_state_mkFSMstate == 4'd3 ||
	     tester_state_mkFSMstate == 4'd4 ||
	     NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	     WILL_FIRE_RL_tester_action_l1724c21 ||
	     tester_state_mkFSMstate == 4'd7 ||
	     tester_state_mkFSMstate == 4'd8 ||
	     WILL_FIRE_RL_tester_action_l1729c9 ||
	     NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687 ;

  // register tester_uart_reading
  assign tester_uart_reading$D_IN = !tester_uart_reading ;
  assign tester_uart_reading$EN =
	     !WILL_FIRE_RL_bridge_letWait &&
	     (tester_uart_reading && !bridge_waitRequest ||
	      !tester_uart_reading && !bridge_waitRequest &&
	      tester_out$EMPTY_N) ;

  // submodule bridge_uartHandler_inputFIFO_memory
  assign bridge_uartHandler_inputFIFO_memory$ADDRA =
	     bridge_uartHandler_inputFIFO_rWrPtr[9:0] ;
  assign bridge_uartHandler_inputFIFO_memory$ADDRB =
	     WILL_FIRE_RL_bridge_uartHandler_prepareForOut ?
	       x__h73317[9:0] :
	       bridge_uartHandler_inputFIFO_rRdPtr[9:0] ;
  assign bridge_uartHandler_inputFIFO_memory$DIA = x3__h73132 ;
  assign bridge_uartHandler_inputFIFO_memory$DIB =
	     8'b10101010 /* unspecified value */  ;
  assign bridge_uartHandler_inputFIFO_memory$WEA =
	     WILL_FIRE_RL_bridge_letWait ;
  assign bridge_uartHandler_inputFIFO_memory$WEB = 1'd0 ;
  assign bridge_uartHandler_inputFIFO_memory$ENA = 1'b1 ;
  assign bridge_uartHandler_inputFIFO_memory$ENB = 1'b1 ;

  // submodule bridge_uartHandler_outputFIFO_memory
  assign bridge_uartHandler_outputFIFO_memory$ADDRA =
	     bridge_uartHandler_outputFIFO_rWrPtr[9:0] ;
  assign bridge_uartHandler_outputFIFO_memory$ADDRB =
	     bridge_uartHandler_outputFIFO_rRdPtr[9:0] ;
  assign bridge_uartHandler_outputFIFO_memory$DIA = x3__h74096 ;
  assign bridge_uartHandler_outputFIFO_memory$DIB =
	     8'b10101010 /* unspecified value */  ;
  assign bridge_uartHandler_outputFIFO_memory$WEA =
	     WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO ;
  assign bridge_uartHandler_outputFIFO_memory$WEB = 1'd0 ;
  assign bridge_uartHandler_outputFIFO_memory$ENA = 1'b1 ;
  assign bridge_uartHandler_outputFIFO_memory$ENB = 1'b1 ;

  // submodule cycler_cyclingFIFO_memory
  assign cycler_cyclingFIFO_memory$ADDRA = cycler_cyclingFIFO_rWrPtr[7:0] ;
  assign cycler_cyclingFIFO_memory$ADDRB =
	     WILL_FIRE_RL_cycler_cycle ?
	       x__h7712[7:0] :
	       cycler_cyclingFIFO_rRdPtr[7:0] ;
  assign cycler_cyclingFIFO_memory$DIA =
	     IF_NOT_cycler_cyclingFIFO_wDataIn_whas__25_26__ETC___d139 ;
  assign cycler_cyclingFIFO_memory$DIB =
	     16'b1010101010101010 /* unspecified value */  ;
  assign cycler_cyclingFIFO_memory$WEA = WILL_FIRE_RL_cycler_cycle ;
  assign cycler_cyclingFIFO_memory$WEB = 1'd0 ;
  assign cycler_cyclingFIFO_memory$ENA = 1'b1 ;
  assign cycler_cyclingFIFO_memory$ENB = 1'b1 ;

  // submodule tester_out
  assign tester_out$D_IN =
	     (NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d436 ||
	      tester_s_failureReg) ?
	       8'd49 :
	       8'd48 ;
  assign tester_out$ENQ =
	     NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687 ;
  assign tester_out$DEQ =
	     !WILL_FIRE_RL_bridge_letWait && !tester_uart_reading &&
	     !bridge_waitRequest &&
	     tester_out$EMPTY_N ;
  assign tester_out$CLR = 1'b0 ;

  // submodule tester_s_timeFIFO
  assign tester_s_timeFIFO$D_IN = 33'h0 ;
  assign tester_s_timeFIFO$ENQ = 1'b0 ;
  assign tester_s_timeFIFO$DEQ = 1'b0 ;
  assign tester_s_timeFIFO$CLR = 1'b0 ;

  // remaining internal signals
  assign IF_NOT_cycler_cyclingFIFO_wDataIn_whas__25_26__ETC___d139 =
	     (!WILL_FIRE_RL_cycler_cycle ||
	      cycler_cyclingFIFO_wDataIn$wget[15:14] == 2'd0) ?
	       { 2'd0,
		 WILL_FIRE_RL_cycler_cycle ?
		   cycler_cyclingFIFO_wDataIn$wget[13:0] :
		   14'd0 } :
	       { CASE_cycler_cyclingFIFO_wDataInwget_BITS_15_T_ETC__q7,
		 cycler_cyclingFIFO_wDataIn$wget[13:0] } ;
  assign IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d214 =
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 &&
	      !IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 &&
	      !cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210) ?
	       4'd10 :
	       4'd0 ;
  assign IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d205 =
	     cycler_cyclingFIFO_wDataOut$wget[10] ?
	       -cycler_cyclingFIFO_wDataOut$wget[10:0] :
	       cycler_cyclingFIFO_wDataOut$wget[10:0] ;
  assign IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206 =
	     (IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d205 ^
	      11'h400) <=
	     11'd2023 ;
  assign IF_cycler_displayer_bcdDecodedInput_0_7_ULE_4__ETC___d80 =
	     (cycler_displayer_bcdDecodedInput_0 <= 4'd4) ?
	       cycler_displayer_bcdDecodedInput_0 :
	       cycler_displayer_bcdDecodedInput_0 + 4'd3 ;
  assign IF_cycler_displayer_bcdDecodedInput_1_8_ULE_4__ETC___d89 =
	     (cycler_displayer_bcdDecodedInput_1 <= 4'd4) ?
	       cycler_displayer_bcdDecodedInput_1 :
	       cycler_displayer_bcdDecodedInput_1 + 4'd3 ;
  assign IF_cycler_displayer_bcdDecodedInput_2_9_ULE_4__ETC___d97 =
	     (cycler_displayer_bcdDecodedInput_2 <= 4'd4) ?
	       cycler_displayer_bcdDecodedInput_2 :
	       cycler_displayer_bcdDecodedInput_2 + 4'd3 ;
  assign IF_cycler_displayer_bcdDecodedInput_3_ULE_4_TH_ETC__q2 =
	     (cycler_displayer_bcdDecodedInput_3 <= 4'd4) ?
	       cycler_displayer_bcdDecodedInput_3 :
	       cycler_displayer_bcdDecodedInput_3 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_0_0_ULE_4_1_T_ETC___d23 =
	     (displayModule_bcdDecodedInput_0 <= 4'd4) ?
	       displayModule_bcdDecodedInput_0 :
	       displayModule_bcdDecodedInput_0 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_1_1_ULE_4_0_T_ETC___d32 =
	     (displayModule_bcdDecodedInput_1 <= 4'd4) ?
	       displayModule_bcdDecodedInput_1 :
	       displayModule_bcdDecodedInput_1 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_2_2_ULE_4_8_T_ETC___d40 =
	     (displayModule_bcdDecodedInput_2 <= 4'd4) ?
	       displayModule_bcdDecodedInput_2 :
	       displayModule_bcdDecodedInput_2 + 4'd3 ;
  assign IF_displayModule_bcdDecodedInput_3_ULE_4_THEN__ETC__q8 =
	     (displayModule_bcdDecodedInput_3 <= 4'd4) ?
	       displayModule_bcdDecodedInput_3 :
	       displayModule_bcdDecodedInput_3 + 4'd3 ;
  assign NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d826 =
	     { 24'd0, switch_ifc_switches_switch_status[15:8] } !=
	     leftInt_valueHolder ;
  assign NOT_0_CONCAT_switch_ifc_switches_switch_status_ETC___d831 =
	     { 24'd0, switch_ifc_switches_switch_status[7:0] } !=
	     rightInt_valueHolder ;
  assign NOT_tester_s_delayedCount_read__16_EQ_0_17_18__ETC___d648 =
	     tester_s_delayedCount != 32'd0 &&
	     tester_s_success_whas__20_AND_NOT_tester_s_suc_ETC___d433 ||
	     tester_s_failureReg ;
  assign NOT_tester_s_success_whas__20_58_OR_tester_s_s_ETC___d665 =
	     tester_s_success$wget && tester_s_1_success$wget &&
	     tester_s_2_success$wget ;
  assign NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 =
	     !tester_s_testDone &&
	     (tester_state_mkFSMstate == 4'd5 ||
	      tester_state_mkFSMstate == 4'd6) ;
  assign NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d436 =
	     tester_s_delayedCount != 32'd0 &&
	     tester_s_success_whas__20_AND_NOT_tester_s_suc_ETC___d433 ;
  assign NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687 =
	     (NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d436 ||
	      tester_s_failureReg) &&
	     tester_state_mkFSMstate == 4'd9 ||
	     tester_state_mkFSMstate == 4'd10 ;
  assign _dfoo1 =
	     cycler_cyclingFIFO_wDataOut_wget__90_BITS_15_T_ETC___d261 ||
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1) &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd1 ||
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206) &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd0 ||
	      cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210) ;
  assign bridge_uartHandler_toSendBits_BITS_10_TO_0__q1 =
	     bridge_uartHandler_toSendBits[10:0] ;
  assign cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210 =
	     cycler_cyclingFIFO_wDataOut$wget[13:0] <= 14'd9999 ;
  assign cycler_cyclingFIFO_wDataOut_wget__90_BITS_15_T_ETC___d261 =
	     cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd1 &&
	     !IF_cycler_cyclingFIFO_wDataOut_wget__90_BIT_10_ETC___d206 ||
	     cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd0 &&
	     !cycler_cyclingFIFO_wDataOut_wget__90_BITS_13_T_ETC___d210 ||
	     cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd0 &&
	     cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd1 &&
	     (cycler_cyclingFIFO_wDataOut$wget[15:14] == 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[1:0] == 2'd2) ||
	      cycler_cyclingFIFO_wDataOut$wget[15:14] != 2'd2 &&
	      (cycler_cyclingFIFO_wDataOut$wget[7:6] == 2'd1 ||
	       cycler_cyclingFIFO_wDataOut$wget[7:6] == 2'd0 ||
	       cycler_cyclingFIFO_wDataOut$wget[7:6] == 2'd2)) ;
  assign spliced_bits__h74984 =
	     (bridge_uartHandler_inputFIFO_rCache[19] &&
	      bridge_uartHandler_inputFIFO_rCache[18:8] ==
	      bridge_uartHandler_inputFIFO_rRdPtr) ?
	       bridge_uartHandler_inputFIFO_rCache[7:0] :
	       bridge_uartHandler_inputFIFO_memory$DOB ;
  assign tester_abort_whas__96_AND_tester_abort_wget__9_ETC___d694 =
	     (tester_state_mkFSMstate == 4'd0 ||
	      tester_state_mkFSMstate == 4'd11) &&
	     (!tester_start_reg_1 || tester_state_fired) ;
  assign tester_s_1_aRandom_prng_state_1_37_MUL_1103515245___d338 =
	     tester_s_1_aRandom_prng_state_1 * 31'd1103515245 ;
  assign tester_s_1_aRandom_prng_state_24_MUL_1103515245___d325 =
	     tester_s_1_aRandom_prng_state * 31'd1103515245 ;
  assign tester_s_1_aRandom_prng_state_2_50_MUL_1103515245___d351 =
	     tester_s_1_aRandom_prng_state_2 * 31'd1103515245 ;
  assign tester_s_2_aRandom_prng_state_1_84_MUL_1103515245___d385 =
	     tester_s_2_aRandom_prng_state_1 * 31'd1103515245 ;
  assign tester_s_2_aRandom_prng_state_71_MUL_1103515245___d372 =
	     tester_s_2_aRandom_prng_state * 31'd1103515245 ;
  assign tester_s_aRandom_prng_state_1_06_MUL_1103515245___d307 =
	     tester_s_aRandom_prng_state_1 * 31'd1103515245 ;
  assign tester_s_aRandom_prng_state_93_MUL_1103515245___d294 =
	     tester_s_aRandom_prng_state * 31'd1103515245 ;
  assign tester_s_count_read__10_ULT_1000___d651 = tester_s_count < 32'd1000 ;
  assign tester_s_seeded_48_AND_NOT_tester_s_waitWire_w_ETC___d456 =
	     tester_s_seeded && !tester_s_prePostActive ;
  assign tester_s_stateGen_state_02_MUL_1103515245___d403 =
	     tester_s_stateGen_state * 31'd1103515245 ;
  assign tester_s_success_whas__20_AND_NOT_tester_s_suc_ETC___d433 =
	     !tester_s_success$wget || !tester_s_1_success$wget ||
	     !tester_s_2_success$wget ;
  assign x3__h73132 = WILL_FIRE_RL_bridge_letWait ? tester_out$D_OUT : 8'd0 ;
  assign x3__h74096 =
	     WILL_FIRE_RL_bridge_uartHandler_enterIntoFIFO ?
	       bridge_uartHandler_receivedBits[7:0] :
	       8'd0 ;
  assign x__h15013 =
	     tester_s_aRandom_prng_state_93_MUL_1103515245___d294[30:0] +
	     31'd12345 ;
  assign x__h15895 =
	     tester_s_aRandom_prng_state_1_06_MUL_1103515245___d307[30:0] +
	     31'd12345 ;
  assign x__h17199 =
	     tester_s_1_aRandom_prng_state_24_MUL_1103515245___d325[30:0] +
	     31'd12345 ;
  assign x__h18081 =
	     tester_s_1_aRandom_prng_state_1_37_MUL_1103515245___d338[30:0] +
	     31'd12345 ;
  assign x__h18963 =
	     tester_s_1_aRandom_prng_state_2_50_MUL_1103515245___d351[30:0] +
	     31'd12345 ;
  assign x__h20202 =
	     tester_s_2_aRandom_prng_state_71_MUL_1103515245___d372[30:0] +
	     31'd12345 ;
  assign x__h20974 =
	     tester_s_2_aRandom_prng_state_1_84_MUL_1103515245___d385[30:0] +
	     31'd12345 ;
  assign x__h21968 =
	     tester_s_stateGen_state_02_MUL_1103515245___d403[30:0] +
	     31'd12345 ;
  assign x__h24100 = tester_s_timer + 32'd1 ;
  assign x__h69973 = tester_s_count + 32'd1 ;
  assign x__h73215 = bridge_uartHandler_inputFIFO_rWrPtr + 11'd1 ;
  assign x__h73317 = bridge_uartHandler_inputFIFO_rRdPtr + 11'd1 ;
  assign x__h74177 = bridge_uartHandler_outputFIFO_rWrPtr + 11'd1 ;
  assign x__h74279 = bridge_uartHandler_outputFIFO_rRdPtr + 11'd1 ;
  assign x__h75426 = 9'd1 << bridge_uartHandler_currentRecvIndex ;
  assign x__h7600 = cycler_cyclingFIFO_rWrPtr + 9'd1 ;
  assign x__h76621 = 4'd1 << cycler_displayer_currentDigitIndex ;
  assign x__h7712 = cycler_cyclingFIFO_rRdPtr + 9'd1 ;
  assign y__h75476 = ~x__h75426 ;
  always@(cycler_displayer_currentDigitIndex or
	  cycler_displayer_bcdDecodedInput_0 or
	  cycler_displayer_bcdDecodedInput_1 or
	  cycler_displayer_bcdDecodedInput_2 or
	  cycler_displayer_bcdDecodedInput_3)
  begin
    case (cycler_displayer_currentDigitIndex)
      2'd0:
	  SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72 =
	      cycler_displayer_bcdDecodedInput_0;
      2'd1:
	  SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72 =
	      cycler_displayer_bcdDecodedInput_1;
      2'd2:
	  SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72 =
	      cycler_displayer_bcdDecodedInput_2;
      2'd3:
	  SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72 =
	      cycler_displayer_bcdDecodedInput_3;
    endcase
  end
  always@(displayModule_currentDigitIndex or
	  displayModule_bcdDecodedInput_0 or
	  displayModule_bcdDecodedInput_1 or
	  displayModule_bcdDecodedInput_2 or displayModule_bcdDecodedInput_3)
  begin
    case (displayModule_currentDigitIndex)
      2'd0:
	  SEL_ARR_displayModule_bcdDecodedInput_0_0_disp_ETC___d15 =
	      displayModule_bcdDecodedInput_0;
      2'd1:
	  SEL_ARR_displayModule_bcdDecodedInput_0_0_disp_ETC___d15 =
	      displayModule_bcdDecodedInput_1;
      2'd2:
	  SEL_ARR_displayModule_bcdDecodedInput_0_0_disp_ETC___d15 =
	      displayModule_bcdDecodedInput_2;
      2'd3:
	  SEL_ARR_displayModule_bcdDecodedInput_0_0_disp_ETC___d15 =
	      displayModule_bcdDecodedInput_3;
    endcase
  end
  always@(cycler_cyclingFIFO_rCache)
  begin
    case (cycler_cyclingFIFO_rCache[15:14])
      2'd0, 2'd1, 2'd2:
	  CASE_cycler_cyclingFIFO_rCache_BITS_15_TO_14_0_ETC__q3 =
	      cycler_cyclingFIFO_rCache[15:14];
      2'd3: CASE_cycler_cyclingFIFO_rCache_BITS_15_TO_14_0_ETC__q3 = 2'd3;
    endcase
  end
  always@(cycler_cyclingFIFO_memory$DOB)
  begin
    case (cycler_cyclingFIFO_memory$DOB[15:14])
      2'd0, 2'd1, 2'd2:
	  CASE_cycler_cyclingFIFO_memoryDOB_BITS_15_TO__ETC__q4 =
	      cycler_cyclingFIFO_memory$DOB[15:14];
      2'd3: CASE_cycler_cyclingFIFO_memoryDOB_BITS_15_TO__ETC__q4 = 2'd3;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataOut$wget)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[1:0])
      2'd0: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216 = 4'd11;
      2'd1: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216 = 4'd10;
      default: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216 =
		   4'd15;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataOut$wget)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[3:2])
      2'd0: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_3_ETC___d231 = 4'd11;
      2'd1: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_3_ETC___d231 = 4'd10;
      default: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_3_ETC___d231 =
		   4'd15;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataOut$wget)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[5:4])
      2'd0: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_5_ETC___d244 = 4'd11;
      2'd1: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_5_ETC___d244 = 4'd10;
      default: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_5_ETC___d244 =
		   4'd15;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataOut$wget)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[7:6])
      2'd0: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_7_ETC___d263 = 4'd11;
      2'd1: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_7_ETC___d263 = 4'd10;
      default: IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_7_ETC___d263 =
		   4'd15;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataOut$wget or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_7_ETC___d263 or
	  IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[15:14])
      2'd0, 2'd1:
	  CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q5 = 4'd10;
      2'd2:
	  CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q5 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_1_ETC___d216;
      2'd3:
	  CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q5 =
	      IF_cycler_cyclingFIFO_wDataOut_wget__90_BITS_7_ETC___d263;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataOut$wget)
  begin
    case (cycler_cyclingFIFO_wDataOut$wget[15:14])
      2'd0, 2'd1, 2'd2:
	  CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q6 =
	      cycler_cyclingFIFO_wDataOut$wget[15:14];
      2'd3: CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q6 = 2'd3;
    endcase
  end
  always@(cycler_cyclingFIFO_wDataIn$wget)
  begin
    case (cycler_cyclingFIFO_wDataIn$wget[15:14])
      2'd1, 2'd2:
	  CASE_cycler_cyclingFIFO_wDataInwget_BITS_15_T_ETC__q7 =
	      cycler_cyclingFIFO_wDataIn$wget[15:14];
      default: CASE_cycler_cyclingFIFO_wDataInwget_BITS_15_T_ETC__q7 = 2'd3;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        bridge_uartHandler_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 27'd0;
	bridge_uartHandler_currentReceivedBit <= `BSV_ASSIGNMENT_DELAY 1'd1;
	bridge_uartHandler_inputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	    20'd174762;
	bridge_uartHandler_inputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	bridge_uartHandler_inputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	bridge_uartHandler_outputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	    20'd174762;
	bridge_uartHandler_outputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	bridge_uartHandler_outputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY 11'd0;
	bridge_uartHandler_receivingData <= `BSV_ASSIGNMENT_DELAY 2'd0;
	bridge_uartHandler_toSendBits <= `BSV_ASSIGNMENT_DELAY 12'd682;
	bridge_waitRequest <= `BSV_ASSIGNMENT_DELAY 1'd1;
	buttonStatus_0 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	buttonStatus_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	buttonStatus_2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	buttonStatus_3 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	buttonStatus_4 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 28'd0;
	currentDigitIndex <= `BSV_ASSIGNMENT_DELAY 2'd0;
	currentIsSigned <= `BSV_ASSIGNMENT_DELAY 1'd0;
	currentNumberS <= `BSV_ASSIGNMENT_DELAY 11'd0;
	currentNumberU <= `BSV_ASSIGNMENT_DELAY 4'd0;
	cycler_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 32'd0;
	cycler_cyclingFIFO_rCache <= `BSV_ASSIGNMENT_DELAY 26'd11184810;
	cycler_cyclingFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY 9'd0;
	cycler_cyclingFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY 9'd0;
	cycler_displayer_bcdDecodedInput_0 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	cycler_displayer_bcdDecodedInput_1 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	cycler_displayer_bcdDecodedInput_2 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	cycler_displayer_bcdDecodedInput_3 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	cycler_displayer_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 19'd0;
	cycler_displayer_currentDigitIndex <= `BSV_ASSIGNMENT_DELAY 2'd0;
	cycler_displayer_isNegative <= `BSV_ASSIGNMENT_DELAY 1'd0;
	cycler_displayer_readyToDisplay <= `BSV_ASSIGNMENT_DELAY 1'd0;
	displayModule_bcdDecodedInput_0 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_bcdDecodedInput_1 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_bcdDecodedInput_2 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_bcdDecodedInput_3 <= `BSV_ASSIGNMENT_DELAY 4'd15;
	displayModule_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY 19'd0;
	displayModule_currentDigitIndex <= `BSV_ASSIGNMENT_DELAY 2'd0;
	displayModule_isNegative <= `BSV_ASSIGNMENT_DELAY 1'd0;
	displayModule_readyToDisplay <= `BSV_ASSIGNMENT_DELAY 1'd0;
	ledStatus <= `BSV_ASSIGNMENT_DELAY 16'd0;
	leftInt_holdsNewValue <= `BSV_ASSIGNMENT_DELAY 1'd0;
	leftInt_valueHolder <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rightInt_holdsNewValue <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rightInt_valueHolder <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_running <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_1_aRandom_prng_state <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_1_aRandom_prng_state_1 <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_1_aRandom_prng_state_2 <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_2_aRandom_prng_state <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_2_aRandom_prng_state_1 <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_aRandom_prng_state <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_aRandom_prng_state_1 <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_chatty <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_consecutiveNonFires <= `BSV_ASSIGNMENT_DELAY 16'd0;
	tester_s_count <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_counterExampleLen <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_currentDepth <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_delayedCount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_deleteNum <= `BSV_ASSIGNMENT_DELAY 33'h0AAAAAAAA;
	tester_s_doneUI <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_failureReg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_gotPlusArgs <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_iterCount <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_loopDone <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_nibbleCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
	tester_s_omitNum <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_prePostActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_resumeFlag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_resumed <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_seedFile <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_seeded <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_startTime <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_state <= `BSV_ASSIGNMENT_DELAY 16'd0;
	tester_s_stateGen_state <= `BSV_ASSIGNMENT_DELAY 31'd0;
	tester_s_testDone <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_testNum <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_timer <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_tmpReg <= `BSV_ASSIGNMENT_DELAY 32'd0;
	tester_s_triggerView <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_verbose <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_viewFlag <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_s_wedgeDetected <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	tester_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	tester_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	tester_uart_reading <= `BSV_ASSIGNMENT_DELAY 1'd1;
      end
    else
      begin
        if (bridge_uartHandler_clockDiv_ctr$EN)
	  bridge_uartHandler_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_clockDiv_ctr$D_IN;
	if (bridge_uartHandler_currentReceivedBit$EN)
	  bridge_uartHandler_currentReceivedBit <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_currentReceivedBit$D_IN;
	if (bridge_uartHandler_inputFIFO_rCache$EN)
	  bridge_uartHandler_inputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_inputFIFO_rCache$D_IN;
	if (bridge_uartHandler_inputFIFO_rRdPtr$EN)
	  bridge_uartHandler_inputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_inputFIFO_rRdPtr$D_IN;
	if (bridge_uartHandler_inputFIFO_rWrPtr$EN)
	  bridge_uartHandler_inputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_inputFIFO_rWrPtr$D_IN;
	if (bridge_uartHandler_outputFIFO_rCache$EN)
	  bridge_uartHandler_outputFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_outputFIFO_rCache$D_IN;
	if (bridge_uartHandler_outputFIFO_rRdPtr$EN)
	  bridge_uartHandler_outputFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_outputFIFO_rRdPtr$D_IN;
	if (bridge_uartHandler_outputFIFO_rWrPtr$EN)
	  bridge_uartHandler_outputFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_outputFIFO_rWrPtr$D_IN;
	if (bridge_uartHandler_receivingData$EN)
	  bridge_uartHandler_receivingData <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_receivingData$D_IN;
	if (bridge_uartHandler_toSendBits$EN)
	  bridge_uartHandler_toSendBits <= `BSV_ASSIGNMENT_DELAY
	      bridge_uartHandler_toSendBits$D_IN;
	if (bridge_waitRequest$EN)
	  bridge_waitRequest <= `BSV_ASSIGNMENT_DELAY bridge_waitRequest$D_IN;
	if (buttonStatus_0$EN)
	  buttonStatus_0 <= `BSV_ASSIGNMENT_DELAY buttonStatus_0$D_IN;
	if (buttonStatus_1$EN)
	  buttonStatus_1 <= `BSV_ASSIGNMENT_DELAY buttonStatus_1$D_IN;
	if (buttonStatus_2$EN)
	  buttonStatus_2 <= `BSV_ASSIGNMENT_DELAY buttonStatus_2$D_IN;
	if (buttonStatus_3$EN)
	  buttonStatus_3 <= `BSV_ASSIGNMENT_DELAY buttonStatus_3$D_IN;
	if (buttonStatus_4$EN)
	  buttonStatus_4 <= `BSV_ASSIGNMENT_DELAY buttonStatus_4$D_IN;
	if (clockDiv_ctr$EN)
	  clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY clockDiv_ctr$D_IN;
	if (currentDigitIndex$EN)
	  currentDigitIndex <= `BSV_ASSIGNMENT_DELAY currentDigitIndex$D_IN;
	if (currentIsSigned$EN)
	  currentIsSigned <= `BSV_ASSIGNMENT_DELAY currentIsSigned$D_IN;
	if (currentNumberS$EN)
	  currentNumberS <= `BSV_ASSIGNMENT_DELAY currentNumberS$D_IN;
	if (currentNumberU$EN)
	  currentNumberU <= `BSV_ASSIGNMENT_DELAY currentNumberU$D_IN;
	if (cycler_clockDiv_ctr$EN)
	  cycler_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY
	      cycler_clockDiv_ctr$D_IN;
	if (cycler_cyclingFIFO_rCache$EN)
	  cycler_cyclingFIFO_rCache <= `BSV_ASSIGNMENT_DELAY
	      cycler_cyclingFIFO_rCache$D_IN;
	if (cycler_cyclingFIFO_rRdPtr$EN)
	  cycler_cyclingFIFO_rRdPtr <= `BSV_ASSIGNMENT_DELAY
	      cycler_cyclingFIFO_rRdPtr$D_IN;
	if (cycler_cyclingFIFO_rWrPtr$EN)
	  cycler_cyclingFIFO_rWrPtr <= `BSV_ASSIGNMENT_DELAY
	      cycler_cyclingFIFO_rWrPtr$D_IN;
	if (cycler_displayer_bcdDecodedInput_0$EN)
	  cycler_displayer_bcdDecodedInput_0 <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_bcdDecodedInput_0$D_IN;
	if (cycler_displayer_bcdDecodedInput_1$EN)
	  cycler_displayer_bcdDecodedInput_1 <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_bcdDecodedInput_1$D_IN;
	if (cycler_displayer_bcdDecodedInput_2$EN)
	  cycler_displayer_bcdDecodedInput_2 <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_bcdDecodedInput_2$D_IN;
	if (cycler_displayer_bcdDecodedInput_3$EN)
	  cycler_displayer_bcdDecodedInput_3 <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_bcdDecodedInput_3$D_IN;
	if (cycler_displayer_clockDiv_ctr$EN)
	  cycler_displayer_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_clockDiv_ctr$D_IN;
	if (cycler_displayer_currentDigitIndex$EN)
	  cycler_displayer_currentDigitIndex <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_currentDigitIndex$D_IN;
	if (cycler_displayer_isNegative$EN)
	  cycler_displayer_isNegative <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_isNegative$D_IN;
	if (cycler_displayer_readyToDisplay$EN)
	  cycler_displayer_readyToDisplay <= `BSV_ASSIGNMENT_DELAY
	      cycler_displayer_readyToDisplay$D_IN;
	if (displayModule_bcdDecodedInput_0$EN)
	  displayModule_bcdDecodedInput_0 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_0$D_IN;
	if (displayModule_bcdDecodedInput_1$EN)
	  displayModule_bcdDecodedInput_1 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_1$D_IN;
	if (displayModule_bcdDecodedInput_2$EN)
	  displayModule_bcdDecodedInput_2 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_2$D_IN;
	if (displayModule_bcdDecodedInput_3$EN)
	  displayModule_bcdDecodedInput_3 <= `BSV_ASSIGNMENT_DELAY
	      displayModule_bcdDecodedInput_3$D_IN;
	if (displayModule_clockDiv_ctr$EN)
	  displayModule_clockDiv_ctr <= `BSV_ASSIGNMENT_DELAY
	      displayModule_clockDiv_ctr$D_IN;
	if (displayModule_currentDigitIndex$EN)
	  displayModule_currentDigitIndex <= `BSV_ASSIGNMENT_DELAY
	      displayModule_currentDigitIndex$D_IN;
	if (displayModule_isNegative$EN)
	  displayModule_isNegative <= `BSV_ASSIGNMENT_DELAY
	      displayModule_isNegative$D_IN;
	if (displayModule_readyToDisplay$EN)
	  displayModule_readyToDisplay <= `BSV_ASSIGNMENT_DELAY
	      displayModule_readyToDisplay$D_IN;
	if (ledStatus$EN) ledStatus <= `BSV_ASSIGNMENT_DELAY ledStatus$D_IN;
	if (leftInt_holdsNewValue$EN)
	  leftInt_holdsNewValue <= `BSV_ASSIGNMENT_DELAY
	      leftInt_holdsNewValue$D_IN;
	if (leftInt_valueHolder$EN)
	  leftInt_valueHolder <= `BSV_ASSIGNMENT_DELAY
	      leftInt_valueHolder$D_IN;
	if (rightInt_holdsNewValue$EN)
	  rightInt_holdsNewValue <= `BSV_ASSIGNMENT_DELAY
	      rightInt_holdsNewValue$D_IN;
	if (rightInt_valueHolder$EN)
	  rightInt_valueHolder <= `BSV_ASSIGNMENT_DELAY
	      rightInt_valueHolder$D_IN;
	if (tester_running$EN)
	  tester_running <= `BSV_ASSIGNMENT_DELAY tester_running$D_IN;
	if (tester_s_1_aRandom_prng_state$EN)
	  tester_s_1_aRandom_prng_state <= `BSV_ASSIGNMENT_DELAY
	      tester_s_1_aRandom_prng_state$D_IN;
	if (tester_s_1_aRandom_prng_state_1$EN)
	  tester_s_1_aRandom_prng_state_1 <= `BSV_ASSIGNMENT_DELAY
	      tester_s_1_aRandom_prng_state_1$D_IN;
	if (tester_s_1_aRandom_prng_state_2$EN)
	  tester_s_1_aRandom_prng_state_2 <= `BSV_ASSIGNMENT_DELAY
	      tester_s_1_aRandom_prng_state_2$D_IN;
	if (tester_s_2_aRandom_prng_state$EN)
	  tester_s_2_aRandom_prng_state <= `BSV_ASSIGNMENT_DELAY
	      tester_s_2_aRandom_prng_state$D_IN;
	if (tester_s_2_aRandom_prng_state_1$EN)
	  tester_s_2_aRandom_prng_state_1 <= `BSV_ASSIGNMENT_DELAY
	      tester_s_2_aRandom_prng_state_1$D_IN;
	if (tester_s_aRandom_prng_state$EN)
	  tester_s_aRandom_prng_state <= `BSV_ASSIGNMENT_DELAY
	      tester_s_aRandom_prng_state$D_IN;
	if (tester_s_aRandom_prng_state_1$EN)
	  tester_s_aRandom_prng_state_1 <= `BSV_ASSIGNMENT_DELAY
	      tester_s_aRandom_prng_state_1$D_IN;
	if (tester_s_chatty$EN)
	  tester_s_chatty <= `BSV_ASSIGNMENT_DELAY tester_s_chatty$D_IN;
	if (tester_s_consecutiveNonFires$EN)
	  tester_s_consecutiveNonFires <= `BSV_ASSIGNMENT_DELAY
	      tester_s_consecutiveNonFires$D_IN;
	if (tester_s_count$EN)
	  tester_s_count <= `BSV_ASSIGNMENT_DELAY tester_s_count$D_IN;
	if (tester_s_counterExampleLen$EN)
	  tester_s_counterExampleLen <= `BSV_ASSIGNMENT_DELAY
	      tester_s_counterExampleLen$D_IN;
	if (tester_s_currentDepth$EN)
	  tester_s_currentDepth <= `BSV_ASSIGNMENT_DELAY
	      tester_s_currentDepth$D_IN;
	if (tester_s_delayedCount$EN)
	  tester_s_delayedCount <= `BSV_ASSIGNMENT_DELAY
	      tester_s_delayedCount$D_IN;
	if (tester_s_deleteNum$EN)
	  tester_s_deleteNum <= `BSV_ASSIGNMENT_DELAY tester_s_deleteNum$D_IN;
	if (tester_s_doneUI$EN)
	  tester_s_doneUI <= `BSV_ASSIGNMENT_DELAY tester_s_doneUI$D_IN;
	if (tester_s_failureReg$EN)
	  tester_s_failureReg <= `BSV_ASSIGNMENT_DELAY
	      tester_s_failureReg$D_IN;
	if (tester_s_gotPlusArgs$EN)
	  tester_s_gotPlusArgs <= `BSV_ASSIGNMENT_DELAY
	      tester_s_gotPlusArgs$D_IN;
	if (tester_s_iterCount$EN)
	  tester_s_iterCount <= `BSV_ASSIGNMENT_DELAY tester_s_iterCount$D_IN;
	if (tester_s_loopDone$EN)
	  tester_s_loopDone <= `BSV_ASSIGNMENT_DELAY tester_s_loopDone$D_IN;
	if (tester_s_nibbleCount$EN)
	  tester_s_nibbleCount <= `BSV_ASSIGNMENT_DELAY
	      tester_s_nibbleCount$D_IN;
	if (tester_s_omitNum$EN)
	  tester_s_omitNum <= `BSV_ASSIGNMENT_DELAY tester_s_omitNum$D_IN;
	if (tester_s_prePostActive$EN)
	  tester_s_prePostActive <= `BSV_ASSIGNMENT_DELAY
	      tester_s_prePostActive$D_IN;
	if (tester_s_resumeFlag$EN)
	  tester_s_resumeFlag <= `BSV_ASSIGNMENT_DELAY
	      tester_s_resumeFlag$D_IN;
	if (tester_s_resumed$EN)
	  tester_s_resumed <= `BSV_ASSIGNMENT_DELAY tester_s_resumed$D_IN;
	if (tester_s_seedFile$EN)
	  tester_s_seedFile <= `BSV_ASSIGNMENT_DELAY tester_s_seedFile$D_IN;
	if (tester_s_seeded$EN)
	  tester_s_seeded <= `BSV_ASSIGNMENT_DELAY tester_s_seeded$D_IN;
	if (tester_s_startTime$EN)
	  tester_s_startTime <= `BSV_ASSIGNMENT_DELAY tester_s_startTime$D_IN;
	if (tester_s_state$EN)
	  tester_s_state <= `BSV_ASSIGNMENT_DELAY tester_s_state$D_IN;
	if (tester_s_stateGen_state$EN)
	  tester_s_stateGen_state <= `BSV_ASSIGNMENT_DELAY
	      tester_s_stateGen_state$D_IN;
	if (tester_s_testDone$EN)
	  tester_s_testDone <= `BSV_ASSIGNMENT_DELAY tester_s_testDone$D_IN;
	if (tester_s_testNum$EN)
	  tester_s_testNum <= `BSV_ASSIGNMENT_DELAY tester_s_testNum$D_IN;
	if (tester_s_timer$EN)
	  tester_s_timer <= `BSV_ASSIGNMENT_DELAY tester_s_timer$D_IN;
	if (tester_s_tmpReg$EN)
	  tester_s_tmpReg <= `BSV_ASSIGNMENT_DELAY tester_s_tmpReg$D_IN;
	if (tester_s_triggerView$EN)
	  tester_s_triggerView <= `BSV_ASSIGNMENT_DELAY
	      tester_s_triggerView$D_IN;
	if (tester_s_verbose$EN)
	  tester_s_verbose <= `BSV_ASSIGNMENT_DELAY tester_s_verbose$D_IN;
	if (tester_s_viewFlag$EN)
	  tester_s_viewFlag <= `BSV_ASSIGNMENT_DELAY tester_s_viewFlag$D_IN;
	if (tester_s_wedgeDetected$EN)
	  tester_s_wedgeDetected <= `BSV_ASSIGNMENT_DELAY
	      tester_s_wedgeDetected$D_IN;
	if (tester_start_reg$EN)
	  tester_start_reg <= `BSV_ASSIGNMENT_DELAY tester_start_reg$D_IN;
	if (tester_start_reg_1$EN)
	  tester_start_reg_1 <= `BSV_ASSIGNMENT_DELAY tester_start_reg_1$D_IN;
	if (tester_state_can_overlap$EN)
	  tester_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      tester_state_can_overlap$D_IN;
	if (tester_state_fired$EN)
	  tester_state_fired <= `BSV_ASSIGNMENT_DELAY tester_state_fired$D_IN;
	if (tester_state_mkFSMstate$EN)
	  tester_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      tester_state_mkFSMstate$D_IN;
	if (tester_uart_reading$EN)
	  tester_uart_reading <= `BSV_ASSIGNMENT_DELAY
	      tester_uart_reading$D_IN;
      end
    if (bridge_uartHandler_currentRecvIndex$EN)
      bridge_uartHandler_currentRecvIndex <= `BSV_ASSIGNMENT_DELAY
	  bridge_uartHandler_currentRecvIndex$D_IN;
    if (bridge_uartHandler_currentSendIndex$EN)
      bridge_uartHandler_currentSendIndex <= `BSV_ASSIGNMENT_DELAY
	  bridge_uartHandler_currentSendIndex$D_IN;
    if (bridge_uartHandler_receivedBits$EN)
      bridge_uartHandler_receivedBits <= `BSV_ASSIGNMENT_DELAY
	  bridge_uartHandler_receivedBits$D_IN;
    if (cycler_displayer_doubleDabbleCtr$EN)
      cycler_displayer_doubleDabbleCtr <= `BSV_ASSIGNMENT_DELAY
	  cycler_displayer_doubleDabbleCtr$D_IN;
    if (cycler_displayer_toDisplay$EN)
      cycler_displayer_toDisplay <= `BSV_ASSIGNMENT_DELAY
	  cycler_displayer_toDisplay$D_IN;
    if (displayModule_doubleDabbleCtr$EN)
      displayModule_doubleDabbleCtr <= `BSV_ASSIGNMENT_DELAY
	  displayModule_doubleDabbleCtr$D_IN;
    if (displayModule_toDisplay$EN)
      displayModule_toDisplay <= `BSV_ASSIGNMENT_DELAY
	  displayModule_toDisplay$D_IN;
    if (tester_s_1_aReg$EN)
      tester_s_1_aReg <= `BSV_ASSIGNMENT_DELAY tester_s_1_aReg$D_IN;
    if (tester_s_1_aReg_1$EN)
      tester_s_1_aReg_1 <= `BSV_ASSIGNMENT_DELAY tester_s_1_aReg_1$D_IN;
    if (tester_s_1_aReg_2$EN)
      tester_s_1_aReg_2 <= `BSV_ASSIGNMENT_DELAY tester_s_1_aReg_2$D_IN;
    if (tester_s_2_aReg$EN)
      tester_s_2_aReg <= `BSV_ASSIGNMENT_DELAY tester_s_2_aReg$D_IN;
    if (tester_s_2_aReg_1$EN)
      tester_s_2_aReg_1 <= `BSV_ASSIGNMENT_DELAY tester_s_2_aReg_1$D_IN;
    if (tester_s_aReg$EN)
      tester_s_aReg <= `BSV_ASSIGNMENT_DELAY tester_s_aReg$D_IN;
    if (tester_s_aReg_1$EN)
      tester_s_aReg_1 <= `BSV_ASSIGNMENT_DELAY tester_s_aReg_1$D_IN;
    if (tester_s_shadows_regs$EN)
      tester_s_shadows_regs <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs$D_IN;
    if (tester_s_shadows_regs_1$EN)
      tester_s_shadows_regs_1 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_1$D_IN;
    if (tester_s_shadows_regs_2$EN)
      tester_s_shadows_regs_2 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_2$D_IN;
    if (tester_s_shadows_regs_3$EN)
      tester_s_shadows_regs_3 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_3$D_IN;
    if (tester_s_shadows_regs_4$EN)
      tester_s_shadows_regs_4 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_4$D_IN;
    if (tester_s_shadows_regs_5$EN)
      tester_s_shadows_regs_5 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_5$D_IN;
    if (tester_s_shadows_regs_6$EN)
      tester_s_shadows_regs_6 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_6$D_IN;
    if (tester_s_shadows_regs_7$EN)
      tester_s_shadows_regs_7 <= `BSV_ASSIGNMENT_DELAY
	  tester_s_shadows_regs_7$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    bridge_uartHandler_clockDiv_ctr = 27'h2AAAAAA;
    bridge_uartHandler_currentReceivedBit = 1'h0;
    bridge_uartHandler_currentRecvIndex = 4'hA;
    bridge_uartHandler_currentSendIndex = 4'hA;
    bridge_uartHandler_inputFIFO_rCache = 20'hAAAAA;
    bridge_uartHandler_inputFIFO_rRdPtr = 11'h2AA;
    bridge_uartHandler_inputFIFO_rWrPtr = 11'h2AA;
    bridge_uartHandler_outputFIFO_rCache = 20'hAAAAA;
    bridge_uartHandler_outputFIFO_rRdPtr = 11'h2AA;
    bridge_uartHandler_outputFIFO_rWrPtr = 11'h2AA;
    bridge_uartHandler_receivedBits = 9'h0AA;
    bridge_uartHandler_receivingData = 2'h2;
    bridge_uartHandler_toSendBits = 12'hAAA;
    bridge_waitRequest = 1'h0;
    buttonStatus_0 = 1'h0;
    buttonStatus_1 = 1'h0;
    buttonStatus_2 = 1'h0;
    buttonStatus_3 = 1'h0;
    buttonStatus_4 = 1'h0;
    clockDiv_ctr = 28'hAAAAAAA;
    currentDigitIndex = 2'h2;
    currentIsSigned = 1'h0;
    currentNumberS = 11'h2AA;
    currentNumberU = 4'hA;
    cycler_clockDiv_ctr = 32'hAAAAAAAA;
    cycler_cyclingFIFO_rCache = 26'h2AAAAAA;
    cycler_cyclingFIFO_rRdPtr = 9'h0AA;
    cycler_cyclingFIFO_rWrPtr = 9'h0AA;
    cycler_displayer_bcdDecodedInput_0 = 4'hA;
    cycler_displayer_bcdDecodedInput_1 = 4'hA;
    cycler_displayer_bcdDecodedInput_2 = 4'hA;
    cycler_displayer_bcdDecodedInput_3 = 4'hA;
    cycler_displayer_clockDiv_ctr = 19'h2AAAA;
    cycler_displayer_currentDigitIndex = 2'h2;
    cycler_displayer_doubleDabbleCtr = 4'hA;
    cycler_displayer_isNegative = 1'h0;
    cycler_displayer_readyToDisplay = 1'h0;
    cycler_displayer_toDisplay = 14'h2AAA;
    displayModule_bcdDecodedInput_0 = 4'hA;
    displayModule_bcdDecodedInput_1 = 4'hA;
    displayModule_bcdDecodedInput_2 = 4'hA;
    displayModule_bcdDecodedInput_3 = 4'hA;
    displayModule_clockDiv_ctr = 19'h2AAAA;
    displayModule_currentDigitIndex = 2'h2;
    displayModule_doubleDabbleCtr = 4'hA;
    displayModule_isNegative = 1'h0;
    displayModule_readyToDisplay = 1'h0;
    displayModule_toDisplay = 14'h2AAA;
    ledStatus = 16'hAAAA;
    leftInt_holdsNewValue = 1'h0;
    leftInt_valueHolder = 32'hAAAAAAAA;
    rightInt_holdsNewValue = 1'h0;
    rightInt_valueHolder = 32'hAAAAAAAA;
    tester_running = 1'h0;
    tester_s_1_aRandom_prng_state = 31'h2AAAAAAA;
    tester_s_1_aRandom_prng_state_1 = 31'h2AAAAAAA;
    tester_s_1_aRandom_prng_state_2 = 31'h2AAAAAAA;
    tester_s_1_aReg = 4'hA;
    tester_s_1_aReg_1 = 4'hA;
    tester_s_1_aReg_2 = 4'hA;
    tester_s_2_aRandom_prng_state = 31'h2AAAAAAA;
    tester_s_2_aRandom_prng_state_1 = 31'h2AAAAAAA;
    tester_s_2_aReg = 4'hA;
    tester_s_2_aReg_1 = 4'hA;
    tester_s_aRandom_prng_state = 31'h2AAAAAAA;
    tester_s_aRandom_prng_state_1 = 31'h2AAAAAAA;
    tester_s_aReg = 4'hA;
    tester_s_aReg_1 = 4'hA;
    tester_s_chatty = 1'h0;
    tester_s_consecutiveNonFires = 16'hAAAA;
    tester_s_count = 32'hAAAAAAAA;
    tester_s_counterExampleLen = 32'hAAAAAAAA;
    tester_s_currentDepth = 32'hAAAAAAAA;
    tester_s_delayedCount = 32'hAAAAAAAA;
    tester_s_deleteNum = 33'h0AAAAAAAA;
    tester_s_doneUI = 1'h0;
    tester_s_failureReg = 1'h0;
    tester_s_gotPlusArgs = 1'h0;
    tester_s_iterCount = 32'hAAAAAAAA;
    tester_s_loopDone = 1'h0;
    tester_s_nibbleCount = 4'hA;
    tester_s_omitNum = 32'hAAAAAAAA;
    tester_s_prePostActive = 1'h0;
    tester_s_resumeFlag = 1'h0;
    tester_s_resumed = 1'h0;
    tester_s_seedFile = 32'hAAAAAAAA;
    tester_s_seeded = 1'h0;
    tester_s_shadows_regs = 32'hAAAAAAAA;
    tester_s_shadows_regs_1 = 32'hAAAAAAAA;
    tester_s_shadows_regs_2 = 32'hAAAAAAAA;
    tester_s_shadows_regs_3 = 32'hAAAAAAAA;
    tester_s_shadows_regs_4 = 32'hAAAAAAAA;
    tester_s_shadows_regs_5 = 32'hAAAAAAAA;
    tester_s_shadows_regs_6 = 32'hAAAAAAAA;
    tester_s_shadows_regs_7 = 32'hAAAAAAAA;
    tester_s_startTime = 32'hAAAAAAAA;
    tester_s_state = 16'hAAAA;
    tester_s_stateGen_state = 31'h2AAAAAAA;
    tester_s_testDone = 1'h0;
    tester_s_testNum = 32'hAAAAAAAA;
    tester_s_timer = 32'hAAAAAAAA;
    tester_s_tmpReg = 32'hAAAAAAAA;
    tester_s_triggerView = 1'h0;
    tester_s_verbose = 1'h0;
    tester_s_viewFlag = 1'h0;
    tester_s_wedgeDetected = 1'h0;
    tester_start_reg = 1'h0;
    tester_start_reg_1 = 1'h0;
    tester_state_can_overlap = 1'h0;
    tester_state_fired = 1'h0;
    tester_state_mkFSMstate = 4'hA;
    tester_uart_reading = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (displayModule_readyToDisplay && displayModule_clockDiv_ctr == 19'd0)
	$display("displayed digit: ",
		 $unsigned(SEL_ARR_displayModule_bcdDecodedInput_0_0_disp_ETC___d15));
    if (RST_N != `BSV_RESET_VALUE)
      if (cycler_displayer_readyToDisplay &&
	  cycler_displayer_clockDiv_ctr == 19'd0)
	$display("displayed digit: ",
		 $unsigned(SEL_ARR_cycler_displayer_bcdDecodedInput_0_7_c_ETC___d72));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_cycler_cycle)
	$display("displaying ",
		 { CASE_cycler_cyclingFIFO_wDataOutwget_BITS_15__ETC__q6,
		   cycler_cyclingFIFO_wDataOut$wget[13:0] },
		 " now");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_running &&
	  tester_abort_whas__96_AND_tester_abort_wget__9_ETC___d694 &&
	  !tester_start_reg)
	$finish(32'd0);
    if (RST_N != `BSV_RESET_VALUE)
      if (!tester_s_gotPlusArgs)
	begin
	  TASK_testplusargs___d280 = $test$plusargs("replay");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (!tester_s_gotPlusArgs)
	begin
	  TASK_testplusargs___d281 = $test$plusargs("resume");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (!tester_s_gotPlusArgs)
	begin
	  TASK_testplusargs___d283 = $test$plusargs("view");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (!tester_s_gotPlusArgs)
	begin
	  TASK_testplusargs___d284 = $test$plusargs("chatty");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write("");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write("%s", "addComm", "(");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_aReg), ",");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_aReg_1));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write(")");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write("\nProperty does not hold");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_success$wget &&
	  tester_s_verbose)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("%s", "addAssoc", "(");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_1_aReg), ",");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_1_aReg_1), ",");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_1_aReg_2));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write(")");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("\nProperty does not hold");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_1_success$wget &&
	  tester_s_verbose)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_action_l1729c9)
	$display("OK: passed %0d iterations", 32'd1000);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_action_l1729c9 &&
	  NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687)
	$display("Error: \"BlueCheck.bsv\", line 1729, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1729c9] and\n  [RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write("");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write("%s", "subComm", "(");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_2_aReg), ",");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write("%d", $signed(tester_s_2_aReg_1));
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write(")");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write("\nProperty does not hold");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_s_checkInvariantBool &&
	  !tester_s_2_success$wget &&
	  tester_s_verbose)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_action_l1684c7 &&
	  (tester_state_mkFSMstate == 4'd1 ||
	   tester_state_mkFSMstate == 4'd2 ||
	   tester_state_mkFSMstate == 4'd3 ||
	   tester_state_mkFSMstate == 4'd4 ||
	   NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	   WILL_FIRE_RL_tester_action_l1724c21 ||
	   tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1684, column 7: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1684c7] and\n  [RL_tester_action_l1694c21, RL_tester_action_np, RL_tester_action_l1696c21,\n  RL_tester_action_l1698c13, RL_tester_action_l1700c9,\n  RL_tester_action_l1724c21, RL_tester_action_np_1, RL_tester_action_l1726c21,\n  RL_tester_action_l1729c9, RL_tester_action_l1733c7] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_state_mkFSMstate == 4'd1 &&
	  (tester_state_mkFSMstate == 4'd2 ||
	   tester_state_mkFSMstate == 4'd3 ||
	   tester_state_mkFSMstate == 4'd4 ||
	   NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	   WILL_FIRE_RL_tester_action_l1724c21 ||
	   tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1694, column 21: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1694c21] and\n  [RL_tester_action_np, RL_tester_action_l1696c21, RL_tester_action_l1698c13,\n  RL_tester_action_l1700c9, RL_tester_action_l1724c21, RL_tester_action_np_1,\n  RL_tester_action_l1726c21, RL_tester_action_l1729c9,\n  RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_state_mkFSMstate == 4'd2 &&
	  (tester_state_mkFSMstate == 4'd3 ||
	   tester_state_mkFSMstate == 4'd4 ||
	   NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	   WILL_FIRE_RL_tester_action_l1724c21 ||
	   tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"StmtFSM.bs\", line 41, column 0: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_np] and\n  [RL_tester_action_l1696c21, RL_tester_action_l1698c13,\n  RL_tester_action_l1700c9, RL_tester_action_l1724c21, RL_tester_action_np_1,\n  RL_tester_action_l1726c21, RL_tester_action_l1729c9,\n  RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_state_mkFSMstate == 4'd3 &&
	  (tester_state_mkFSMstate == 4'd4 ||
	   NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	   WILL_FIRE_RL_tester_action_l1724c21 ||
	   tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1696, column 21: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1696c21] and\n  [RL_tester_action_l1698c13, RL_tester_action_l1700c9,\n  RL_tester_action_l1724c21, RL_tester_action_np_1, RL_tester_action_l1726c21,\n  RL_tester_action_l1729c9, RL_tester_action_l1733c7] ) fired in the same\n  clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_state_mkFSMstate == 4'd4 &&
	  (NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 ||
	   WILL_FIRE_RL_tester_action_l1724c21 ||
	   tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1698, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1698c13] and\n  [RL_tester_action_l1700c9, RL_tester_action_l1724c21, RL_tester_action_np_1,\n  RL_tester_action_l1726c21, RL_tester_action_l1729c9,\n  RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (NOT_tester_s_testDone_38_39_AND_NOT_tester_abo_ETC___d644 &&
	  (WILL_FIRE_RL_tester_action_l1724c21 ||
	   tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1700, column 9: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1700c9] and\n  [RL_tester_action_l1724c21, RL_tester_action_np_1,\n  RL_tester_action_l1726c21, RL_tester_action_l1729c9,\n  RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_state_mkFSMstate == 4'd7 &&
	  (tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"StmtFSM.bs\", line 41, column 0: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_np_1] and\n  [RL_tester_action_l1726c21, RL_tester_action_l1729c9,\n  RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_tester_action_l1724c21 &&
	  (tester_state_mkFSMstate == 4'd7 ||
	   tester_state_mkFSMstate == 4'd8 ||
	   WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1724, column 21: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1724c21] and\n  [RL_tester_action_np_1, RL_tester_action_l1726c21, RL_tester_action_l1729c9,\n  RL_tester_action_l1733c7] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (tester_state_mkFSMstate == 4'd8 &&
	  (WILL_FIRE_RL_tester_action_l1729c9 ||
	   NOT_tester_s_waitWire_whas__14_15_AND_NOT_test_ETC___d687))
	$display("Error: \"BlueCheck.bsv\", line 1726, column 21: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_tester_action_l1726c21] and\n  [RL_tester_action_l1729c9, RL_tester_action_l1733c7] ) fired in the same\n  clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkTopModule

